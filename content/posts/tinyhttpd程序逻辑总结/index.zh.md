+++
title = 'tinyhttpd程序逻辑总结'
date = 2024-03-20T12:06:34+08:00
+++

tinyhttpd是一个非常简易的HTTP服务器程序，适合Linux服务器编程入门学习。从中不仅可以学习到HTTP服务器对一个HTTP请求的响应过程，还能熟悉一些最基本的Linux网络编程api的使用方法。

以下是我对tinyhttpd程序逻辑的简单总结，可以对照公开的源码进行阅读（推荐[详细注释版](https://github.com/cbsheng/tinyhttpd)），在阅读之前读者应该了解计算机网络以及Linux服务器编程的基本知识。

## 程序主要工作流程

1. 服务器启动，在某个端口绑定httpd服务，等待HTTP请求（`main`建立监听socket）
2. 收到一个HTTP请求时（监听socket被`accept`后得到一个连接socket），对它进行处理（执行`accept_request`函数）
3. 解析HTTP请求报文的请求行，从中提取出`method`和`url`，根据两者的内容执行相应的业务逻辑
   - 对于GET方法，解析`url`，获取客户所请求的文件路径`path`。如果`path`是一个目录，则追加`"index.html"`，表示访问主页。如果`path`不存在，则报错返回。否则，如果`path`存在且不是可执行文件，就将该文件封装成响应报文发送给客户（文件基本信息作为首部行，文件内容作为实体主体），跳到最后一步
   - 对于POST方法以及“GET一个可执行文件”，后续将执行cgi业务逻辑
4. 执行cgi业务逻辑
   1. 建立两个单向管道用于进程间通信
   2. 创建子进程
   3. 在子进程中，首先将标准输入输出分别重定向到输入管道的读端和输出管道的写端，然后设置环境变量，执行cgi脚本文件
   4. 在父进程中，首先，如果有必要，通过管道将请求行后面的内容发送给子进程。然后，将子进程通过管道发来的数据发送给客户
5. 关闭连接socket，完成对一次HTTP请求的响应。

## 重要函数解读

### main

- 设定服务端口号
- 创建监听socket（详细工作交由`startup`函数完成）
- 循环阻塞等待客户连接
- 一旦收到客户连接（`accept`成功返回一个连接socket），就处理它（详细工作交由`accept_request`函数完成）
- 程序退出前关闭监听socket

### startup

该函数的主要工作是创建一个监听socket，并将其返回给`main`

- 创建一个使用TCP协议的socket（通过调用`socket`函数，指定协议族和服务类型）
- 设定socket地址结构（涉及通过地址转换函数完成主机字节序到网络字节序的转换）
- 给socket命名，也就是给刚刚创建好的socket绑定一个socket地址（通过调用`bind`函数，端口号已由`main`给出）
- 如果`main`给出的端口号为`0`，即`bind`中指定的socket地址端口号为`0`，系统会随机选择一个临时端口号。在这种情况下，我们需要知道系统给监听socket实际分配的端口号是多少（通过`getsockname`获取，注意要进行字节序转换）
- 调用`listen`函数，让命名后的socket变为监听socket（系统会创建一个监听队列以存放待处理的客户连接）
- 返回监听socket

### accept_request

该函数的主要工作是处理一个HTTP请求。由于该服务器程序实现的是非持续连接的HTTP，即每个HTTP请求都对应一次连接，因此该函数实际上是在处理一个连接socket。

- 解析HTTP请求报文的请求行，获取`method`以及`url`（通过调用自定义函数`get_line`，从连接socket中读取一行，进而处理字符序列）

- 根据`method`和`url`中的信息，明确这个HTTP请求需要执行cgi程序还是仅索要文件

  - POST

    需要执行cgi程序，将cgi标志变量(`cgi`)置`1`。

  - GET

    解析`url`，获取请求的路径(`path`)。（`url`中`'?'`后面的字符串表示请求的路径）

    - `path`是一个目录（以`'/'`结尾），就拼接上`"index.html"`，使其变成文件
    - `path`是一个文件或目录，就查询`path`所表示的文件或目录是否存在（利用`stat`函数）：
      - 不存在，就把该HTTP请求的后续内容读完并忽略，然后返回一个表示“找不到文件”的相应报文给客户（详细工作交由`not_found`函数完成）
      - 存在，就考察它究竟是一个目录还是一个文件（利用`st_mode`）
        - 是目录，就拼接上`"index.html"`，使其变成文件
        - 是可执行文件，需要调用cgi程序，将`cgi`置`1`

- 根据`cgi`的值，发送文件(`serve_file`)或执行cig程序(`execute_cgi`)

- 关闭连接socket

### execute_cgi

该函数的主要工作是进行cgi业务逻辑，该过程涉及创建子进程、利用管道进行进程间通信、执行cgi脚本文件。

- 如果请求方法是GET，就读取并忽略请求行后面的所有内容（实际上请求行后面的内容只有首部行，因为没有实体主体）
- 如果请求方法是POST，在首部行中寻找表示实体主体长度的字段，并记录实体主体长度（如果没有给出长度，则报错返回）
- 给客户发送响应报文中状态行内容(`send` + `"HTTP/1.0 200 OK\r\n"`)
- 创建两个单向管道(`cgi_output`和`cgi_input`)，用于进程间通信(`pipe`)
- 创建子进程(`fork`)
- 子进程将执行cgi脚本
  - 关闭`cgi_output[0]`和`cgi_input[1]`，因为子进程不使用这两端
  - 将标准输入重定向到输出管道的写端，这样一来，子进程输出的内容就会直接写到输出管道的写端
  - 将标准输入重定向到输入管道的读端，这样一来，子进程输入的内容就来自输入管道的读端
  - 设置环境变量
  - 执行cgi脚本文件(`execl`)
- 父进程作为连接socket和子进程之间I/O的中介
  - 关闭`cgi_output[1]`和`cgi_input[0]`，因为父进程不使用这两端
  - 如果请求方法是POST，则继续读取实体主体中的内容，并写到`cgi_input[1]`，让子进程去读
  - 从`cgi_output[0]`中读取子进程的输出，并将其发送给客户
  - 关闭管道，并等待子进程退出

（完）