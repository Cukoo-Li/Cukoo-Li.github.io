
[{"content":"欢迎来到我的小世界\n","date":"2024-04-30","externalUrl":null,"permalink":"/","section":"","summary":"","title":"","type":"page"},{"content":"快速排序和归并排序是面试中常考的排序算法。\n本文首先简单介绍快速排序和归并排序的算法思想，然后分别给出两者在数组和链表两种数据结构中的算法实现（迭代法+递归法）。\n快速排序 #\r快速排序的算法思想是：在待排序表{1...n}中任取一个元素作为枢轴pivot，通过一趟排序将待排序表划分为独立的两部分{1...k-1}和{k+1...n}，使得{1...k-1}中的所有元素小于枢轴pivot，{k+1...n}中所有元素大于等于枢轴pivot，则枢轴pivot放在了其最终位置k上，这个过程称为一趟快速排序（或一次划分）。然后分别递归地对两个子表重复上述过程，直至子表内只有一个元素或为空为止，即所有元素都放在了其最终位置上。\n由此可见，快速排序本身就是一种基于递归的算法。算法实现的关键是要在单次递归逻辑中，将给定的待排序表划分成两部分。此外，我们还可以使用栈去模拟递归调用的过程。\n排序数组 #\r递归法\n// 对区间[left, right]内的元素进行快速排序 void QuickSort(vector\u0026lt;int\u0026gt;\u0026amp; nums, int left, int right) { if (left \u0026gt;= right) return; int pivot_idx = Partition(nums, left, right); // 进行一次划分 QuickSort(nums, left, pivot_idx - 1); // 对左半部分进行快速排序 QuickSort(nums, pivot_idx + 1, right); // 对右半部分进行快速排序 } // 对区间[left, right]内的元素进行划分，返回枢轴下标 int Partition(vector\u0026lt;int\u0026gt;\u0026amp; nums, int left, int right) { int pivot = nums[left]; // 选取首元素作为枢轴 while (left \u0026lt; right) { // 从右往左扫描，将小于枢轴的元素放到左边 while (left \u0026lt; right \u0026amp;\u0026amp; nums[right] \u0026gt;= pivot) --right; nums[left] = nums[right]; // 从左往右扫描，将大于等于枢轴的元素放到右边 while (left \u0026lt; right \u0026amp;\u0026amp; nums[left] \u0026lt; pivot) ++left; nums[right] = nums[left]; } nums[left] = pivot; // 将枢轴放到最终位置上 return left; } 迭代法\n// 对区间[left, right]内的元素进行快速排序 void QuickSort(vector\u0026lt;int\u0026gt;\u0026amp; nums, int left, int right) { if (left \u0026gt;= right) return; stack\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; sta; // 用栈存储区间范围，用于调用 Partition sta.push({left, right}); while (!sta.empty()) { // 获取当前区间范围 auto interval = sta.top(); sta.pop(); int pivot_idx = Partition(nums, interval.first, interval.second); // 将左半部分区间范围入栈 if (interval.first \u0026lt; pivot_idx - 1) sta.push({interval.first, pivot_idx - 1}); // 将右半部分区间范围入栈 if (pivot_idx + 1 \u0026lt; interval.second) sta.push({pivot_idx + 1,interval.second}); } } // 对区间[left, right]内的元素进行划分，返回枢轴下标 int Partition(vector\u0026lt;int\u0026gt;\u0026amp; nums, int left, int right) { int pivot = nums[left]; // 选取首元素作为枢轴 while (left \u0026lt; right) { // 从右往左扫描，将小于枢轴的元素放到左边 while (left \u0026lt; right \u0026amp;\u0026amp; nums[right] \u0026gt;= pivot) --right; nums[left] = nums[right]; // 从左往右扫描，将大于等于枢轴的元素放到右边 while (left \u0026lt; right \u0026amp;\u0026amp; nums[left] \u0026lt; pivot) ++left; nums[right] = nums[left]; } nums[left] = pivot; // 将枢轴放到最终位置上 return left; } 排序链表 #\r递归法\nclass Solution { // 对区间(dummy_head, end)内的元素进行快速排序 void QuickSort(ListNode* dummy_head, ListNode* end) { if (dummy_head-\u0026gt;next == end || dummy_head-\u0026gt;next-\u0026gt;next == end) return; ListNode* pivot = Partition(dummy_head, end); // 划分，确定枢轴 QuickSort(dummy_head, pivot); // 对左半部分进行快速排序 QuickSort(pivot, end); // 对右半部分进行快速排序 } // 对区间(dummy_head, end)内的元素进行划分，返回指向枢轴的指针 ListNode* Partition(ListNode* dummy_head, ListNode* end) { ListNode* pivot = dummy_head-\u0026gt;next; // 选取首元素作为枢轴元素 ListNode* prev = pivot; // 遍历链表，将小于枢轴的元素插入到链表头 while (prev-\u0026gt;next != end) { if (prev-\u0026gt;next-\u0026gt;val \u0026lt; pivot-\u0026gt;val) { ListNode* node = prev-\u0026gt;next; prev-\u0026gt;next = prev-\u0026gt;next-\u0026gt;next; ListNode* tmp = dummy_head-\u0026gt;next; dummy_head-\u0026gt;next = node; node-\u0026gt;next = tmp; } else prev = prev-\u0026gt;next; } return pivot; } public: ListNode* sortList(ListNode* head) { ListNode* dummy_head = new ListNode(0, head); QuickSort(dummy_head, nullptr); head = dummy_head-\u0026gt;next; delete dummy_head; return head; } }; 迭代法\nclass Solution { // 对区间(dummy_head, end)内的元素进行快速排序 void QuickSort(ListNode* dummy_head, ListNode* end) { if (dummy_head-\u0026gt;next == end || dummy_head-\u0026gt;next-\u0026gt;next == end) return; stack\u0026lt;pair\u0026lt;ListNode*, ListNode*\u0026gt;\u0026gt; sta; // 用栈存储区间范围，用于调用 Partition sta.push({dummy_head, end}); while (!sta.empty()) { // 获取当前区间范围 auto interval = sta.top(); sta.pop(); ListNode* pivot = Partition(interval.first, interval.second); // 将左半部分区间范围入栈 if (interval.first-\u0026gt;next != pivot \u0026amp;\u0026amp; interval.first-\u0026gt;next-\u0026gt;next != pivot) sta.push({interval.first, pivot}); // 将右半部分区间范围入栈 if (pivot-\u0026gt;next != interval.second \u0026amp;\u0026amp; pivot-\u0026gt;next-\u0026gt;next != interval.second) sta.push({pivot, interval.second}); } } // 对区间(dummy_head, end)内的元素进行划分，返回指向枢轴的指针 ListNode* Partition(ListNode* dummy_head, ListNode* end) { ListNode* pivot = dummy_head-\u0026gt;next; // 选取首元素作为枢轴元素 ListNode* prev = pivot; // 遍历链表，将小于枢轴的元素插入到链表头 while (prev-\u0026gt;next != end) { if (prev-\u0026gt;next-\u0026gt;val \u0026lt; pivot-\u0026gt;val) { ListNode* node = prev-\u0026gt;next; prev-\u0026gt;next = prev-\u0026gt;next-\u0026gt;next; ListNode* tmp = dummy_head-\u0026gt;next; dummy_head-\u0026gt;next = node; node-\u0026gt;next = tmp; } else prev = prev-\u0026gt;next; } return pivot; } public: ListNode* sortList(ListNode* head) { ListNode* dummy_head = new ListNode(0, head); QuickSort(dummy_head, nullptr); head = dummy_head-\u0026gt;next; delete dummy_head; return head; } }; 归并排序 #\r归并排序的思想是：初始时，将待排序表视为n个只含1个元素的有序子表，然后两两归并，合并成一个更大的有序表，直到合并成一个长度为n的有序表为止。\n由此可见，归并排序的思想非常简洁，关键是一开始要找出只含1个元素的有序子表，然后慢慢生成更长的有序表。这个过程可以使用递归法自顶向下地实现，也可以使用迭代法自底向上地实现。\n排序数组 #\r递归法\nvector\u0026lt;int\u0026gt; tmp; // 对区间[left, right]内的元素进行归并排序 void MergeSort(vector\u0026lt;int\u0026gt;\u0026amp; nums, int left, int right) { if (left \u0026gt;= right) return; int mid = left + (right - left) / 2; // 从中间划分 MergeSort(nums, left, mid); // 对左半部分进行归并排序 MergeSort(nums, mid + 1, right); // 对右半部分进行归并排序 Merge(nums, left, mid, right); // 左半部分和右半部分各自有序，将二者归并 } // 区间[left, mid]和区间[mid + 1, right]各自有序，将二者归并 void Merge(vector\u0026lt;int\u0026gt;\u0026amp; nums, int left, int mid, int right) { // 对区间内的元素进行备份 tmp.resize(nums.size(), 0); std::copy(nums.begin() + left, nums.begin() + right + 1, tmp.begin() + left); // 三指针，依次取较小值 int i = left; int j = mid + 1; int k = left; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= right) { if (tmp[i] \u0026lt;= tmp[j]) nums[k++] = tmp[i++]; else nums[k++] = tmp[j++]; } // 将较长有序表中剩余的元素依次取完 while (i \u0026lt;= mid) nums[k++] = tmp[i++]; while (j \u0026lt;= right) nums[k++] = tmp[j++]; } 迭代法\nvector\u0026lt;int\u0026gt; tmp; // 对区间[left, right]内的元素进行归并排序 void MergeSort(vector\u0026lt;int\u0026gt;\u0026amp; nums) { if (left \u0026gt;= right) return; // 从步长 d 为 1 开始归并，每趟翻倍 for (int d = 1; d \u0026lt; nums.size(); d *= 2) { int cur = 0; // 每次归并的起点 while (cur \u0026lt; nums.size()) { // 确定将要归并的两个区间边界 int left = cur; int mid = cur + d - 1; int right = std::min(static_cast\u0026lt;int\u0026gt;(nums.size() - 1), mid + d); if (mid \u0026lt; right) Merge(nums, left, mid, right); cur = right + 1; } } } // [left, mid]和[mid + 1, right]各自有序，将二者归并 void Merge(vector\u0026lt;int\u0026gt;\u0026amp; nums, int left, int mid, int right) { // 对区间内的元素进行备份 tmp.resize(nums.size(), 0); std::copy(nums.begin() + left, nums.begin() + right + 1, tmp.begin() + left); // 三指针，依次取较小值 int i = left; int j = mid + 1; int k = left; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= right) { if (tmp[i] \u0026lt;= tmp[j]) nums[k++] = tmp[i++]; else nums[k++] = tmp[j++]; } // 将较长有序表中剩余的元素依次取完 while (i \u0026lt;= mid) nums[k++] = tmp[i++]; while (j \u0026lt;= right) nums[k++] = tmp[j++]; } 排序链表 #\r递归法\nclass Solution { // 对链表 head 进行归并排序 ListNode* MergeSort(ListNode* head) { if (!head || !head-\u0026gt;next) return head; // 将链表对半切开 ListNode* slow = head; ListNode* fast = head; while (fast-\u0026gt;next \u0026amp;\u0026amp; fast-\u0026gt;next-\u0026gt;next) { slow = slow-\u0026gt;next; fast = fast-\u0026gt;next-\u0026gt;next; } ListNode* left = head; ListNode* right = slow-\u0026gt;next; slow-\u0026gt;next = nullptr; // 对左半部分和右半部分分别进行归并排序 left = MergeSort(left); right = MergeSort(right); // 归并 return Merge(left, right); } // 链表 left 和 right 各自有序，将二者归并 ListNode* Merge(ListNode* left, ListNode* right) { ListNode* dummy_head = new ListNode(0); ListNode* cur = dummy_head; while (left \u0026amp;\u0026amp; right) { if (left-\u0026gt;val \u0026lt;= right-\u0026gt;val) { cur-\u0026gt;next = left; left = left-\u0026gt;next; } else { cur-\u0026gt;next = right; right = right-\u0026gt;next; } cur = cur-\u0026gt;next; } cur-\u0026gt;next = left ? left : right; ListNode* head = dummy_head-\u0026gt;next; delete dummy_head; return head; } public: ListNode* sortList(ListNode* head) { return MergeSort(head); } }; 迭代法\nclass Solution { // 对链表 head 进行归并排序 ListNode* MergeSort(ListNode* head) { if (!head || !head-\u0026gt;next) return head; // 计算链表长度 int length = 0; for (ListNode* cur = head; cur; cur = cur-\u0026gt;next) ++length; // 创建虚拟头结点 ListNode* dummy_head = new ListNode(0, head); // 从步长 d 为 1 开始归并，每趟翻倍 for (int d = 1; d \u0026lt; length; d *= 2) { ListNode* cur = dummy_head-\u0026gt;next; ListNode* prev = dummy_head; // 用于连接归并结果 // 按步长 d 提取出左、右子链表 while (cur) { ListNode* left = cur; for (int i = 1; i \u0026lt; d \u0026amp;\u0026amp; cur-\u0026gt;next; ++i) cur = cur-\u0026gt;next; ListNode* right = cur-\u0026gt;next; // 如果子链表 right 不存在，不用归并，直接连接子链表 left if (!right) { prev-\u0026gt;next = left; break; } cur-\u0026gt;next = nullptr; cur = right; for (int i = 1; i \u0026lt; d \u0026amp;\u0026amp; cur-\u0026gt;next; ++i) cur = cur-\u0026gt;next; // 保存剩余的未归并的链表 ListNode* remain = cur-\u0026gt;next; cur-\u0026gt;next = nullptr; // 归并，并连接结果 prev-\u0026gt;next = Merge(left, right); // 更新 prev 和 cur while (prev-\u0026gt;next) prev = prev-\u0026gt;next; cur = remain; } } head = dummy_head-\u0026gt;next; delete dummy_head; return head; } // 链表 left 和 right 各自有序，将二者归并 ListNode* Merge(ListNode* left, ListNode* right) { ListNode* dummy_head = new ListNode(0); ListNode* cur = dummy_head; while (left \u0026amp;\u0026amp; right) { if (left-\u0026gt;val \u0026lt;= right-\u0026gt;val) { cur-\u0026gt;next = left; left = left-\u0026gt;next; } else { cur-\u0026gt;next = right; right = right-\u0026gt;next; } cur = cur-\u0026gt;next; } cur-\u0026gt;next = left ? left : right; ListNode* head = dummy_head-\u0026gt;next; delete dummy_head; return head; } public: ListNode* sortList(ListNode* head) { return MergeSort(head); } }; ","date":"2024-04-30","externalUrl":null,"permalink":"/posts/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/","section":"文章","summary":"","title":"快速排序和归并排序","type":"posts"},{"content":"","date":"2024-04-30","externalUrl":null,"permalink":"/posts/","section":"文章","summary":"","title":"文章","type":"posts"},{"content":"KMP 算法是著名的字符串匹配算法。所谓字符串匹配，其实就是子串（常称为模式串）的定位操作，它求的是模式串在主串中的位置。\n对朴素模式匹配算法的改进 #\r对于字符串匹配问题，我们很容易想到暴力解法（即朴素模式匹配算法）：枚举主串中的每一个位置，考虑以其作为起点，与模式串中对应位置的元素进行匹配。一旦在某个位置匹配不上（失配），就考虑以下一个位置为起点，重新与模式串进行匹配，如此反复进行。\n很显然，朴素模式匹配算法的时间复杂度为$O(n×m)$。\nint strStr(string haystack, string needle) { for (int i = 0; i + needle.size() \u0026lt;= haystack.size(); ++i) { bool flag = true; for (int j = 0; j \u0026lt; needle.size(); ++j) { if (haystack[i + j] != needle[j]) { flag = false; break; } } if (flag) return i; } return -1; } 朴素模式匹配算法的思想真的很朴素——不管在什么位置，只要发生失配，都选择以主串起点的下一个位置作为新起点，与模式串从头开始匹配。但这真的有必要吗？换句话说，发生失配时，我们真的需要以下一个位置为起点从头再来吗？是否有更好的选择呢？肯定是有的，下面我们来分析一下。\n以下图为例，当我们在模式串下标为5的位置发生失配时，主串中对应于子串前面的部分（即主串下标为3到7的部分）的内容，我们是知道的。因为这些位置跟与模式串是匹配的。\n按照暴力解法，接下来的一轮匹配操作将如下图所示。我们可以把这一轮匹配操作分为两个部分：首先是与主串中已知部分的匹配（橙色部分），然后是与主串中未知部分匹配（绿色部分）。对于橙色部分，实际上就相当于拿着模式串中0到4子串(\u0026quot;abaab\u0026quot;)的长度为 4 的前缀(\u0026quot;abaa\u0026quot;)和长度为 4 的后缀(\u0026quot;baab\u0026quot;)进行匹配。但这个结果我们是可以事先计算好的，因为它只与模式串相关，而且模式串本身较短，计算量并不大。如果我们事先已经知道\u0026quot;abaab\u0026quot;长度为 4 的前后缀不相等，我们就完全没必要考虑以主串位置4为起点。\n同理，以主串位置5为起点也是没有必要的，因为\u0026quot;abaab\u0026quot;长度为 3 的前后缀并不相等。\n但以主串位置6为起点是有必要的，因为\u0026quot;abaab\u0026quot;长度为 2 的前后缀是相等的，都是\u0026quot;ab\u0026quot;。此时，我们应该从子串下标为2的位置开始匹配，如下图所示：\n从上述例子中，我们可以归纳出如下解决方案，它适用于在模式串各个位置发生失配的情况：\n当在模式串下标为j的位置与主串位置i发生失配时，指针j可以直接跳转到某一下标重新与主串的当前位置i进行比较，这个下标等于模式串中0到j - 1子串的最长相等前后缀长度。如下图所示：\n因此，我们只需要事先计算出模式串中0到j - 1子串的最长相等前后缀长度，就能省去朴素模式匹配算法中许多不必要的比较操作。这就是 KMP 算法的核心思想。\nKMP 算法核心思想 #\rKMP 算法的核心思想可总结为如下两点：\n计算next数组，next[j]表示模式串中0 - j子串的最长相等前后缀长度 在模式串下标为j的位置与主串发生失配时，跳转到next[j - 1]的位置重新与主串的当前位置进行比较 通过这一思路，可以实现主串指针不回溯，算法时间复杂度为$O(n+m)$。\nKMP 算法代码实现 #\rvector\u0026lt;int\u0026gt; BuildNext(const string\u0026amp; patt) { vector\u0026lt;int\u0026gt; next(patt.size(), 0); int prefix_len = 0;\t// 当前的共同前后缀长度 int i = 1; while (i \u0026lt; patt.size()) { if (patt[i] == patt[prefix_len]) next[i++] = ++prefix_len; else if (prefix_len == 0) next[i++] = 0; else prefix_len = next[prefix_len - 1]; } return next; } int KMP(string haystack, string needle) { auto next = BuildNext(needle); int i = 0; // 主串指针 int j = 0; // 子串指针 while (i \u0026lt; haystack.size()) { if (haystack[i] == needle[j]) {\t// 字符匹配，指针后移 ++i; ++j; } else if (j \u0026gt; 0)\t// 失配，根据 next 修改子串指针 j j = next[j - 1]; else // 子串第一个字符就错了 ++i; if (j == needle.size())\t// 匹配成功 return i - j; } return -1; } 结语 #\r实际上，KMP 算法最难的地方就是next数组的计算。然而我并没有对这方面进行讲解，主要是因为最近太忙了，写博客是一件比较花时间的事情，等后面有空了再来把这部分内容补上吧。\n","date":"2024-03-29","externalUrl":null,"permalink":"/posts/kmp%E7%AE%97%E6%B3%95/","section":"文章","summary":"","title":"KMP 算法","type":"posts"},{"content":"手写shared_ptr是面试的常考点，提前准备一下吧。\nshared_ptr 的关键特性 #\r首先明确shared_ptr的关键特性：\n允许多个shared_ptr指向同一个对象 每个shared_ptr都有一个关联的引用计数，用于记录总共有多少个shared_ptr指向相同的对象 一旦一个shared_ptr所关联的引用计数变为 0，它就会自动释放自己所管理的对象 代码思路 #\r显然，最关键的就是要实现引用计数这个机制，大致思路如下：\n在堆中创建一个整型对象作为引用计数 在拷贝或赋值时修改引用计数 在析构函数中递减引用计数，并考察它是否变为 0，如果变为 0，则释放所指向的对象以及引用计数对象 代码实现 #\r#include \u0026lt;iostream\u0026gt; template \u0026lt;typename T\u0026gt; class TinySharedPtr { public: // 构造函数 explicit TinySharedPtr(T* ptr = nullptr) : ptr_(ptr) { if (ptr_) count_ = new int(1); } // 拷贝构造函数 TinySharedPtr(const TinySharedPtr\u0026amp; other) : ptr_(other.ptr_), count_(other.count_) { if (count_) ++*count_; } // 拷贝赋值运算符 TinySharedPtr\u0026amp; operator=(TinySharedPtr other) { std::swap(ptr_, other.ptr_); std::swap(count_, other.count_); return *this; } // 析构函数 ~TinySharedPtr() { if (count_ \u0026amp;\u0026amp; --(*count_) == 0) { delete ptr_; delete count_; } } T* get() { return ptr_; } T* operator-\u0026gt;() { return ptr_; } T\u0026amp; operator*() { return *ptr_; } int use_count() { return count_ ? *count_ : 0; } private: T* ptr_ = nullptr; int* count_ = nullptr; }; struct Cukoo { Cukoo() { puts(\u0026#34;Cukoo()\u0026#34;); } ~Cukoo() { puts(\u0026#34;~Cukoo()\u0026#34;); } int age = 24; }; int main() { TinySharedPtr\u0026lt;Cukoo\u0026gt; sp0; std::cout \u0026lt;\u0026lt; \u0026#34;sp0: \u0026#34; \u0026lt;\u0026lt; sp0.use_count() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; { TinySharedPtr\u0026lt;Cukoo\u0026gt; sp1(new Cukoo()); std::cout \u0026lt;\u0026lt; \u0026#34;age: \u0026#34; \u0026lt;\u0026lt; sp1-\u0026gt;age \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;sp1: \u0026#34; \u0026lt;\u0026lt; sp1.use_count() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; TinySharedPtr\u0026lt;Cukoo\u0026gt; sp2(sp1); std::cout \u0026lt;\u0026lt; \u0026#34;sp2: \u0026#34; \u0026lt;\u0026lt; sp2.use_count() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; sp0 = sp2; std::cout \u0026lt;\u0026lt; \u0026#34;sp0: \u0026#34; \u0026lt;\u0026lt; sp2.use_count() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } std::cout \u0026lt;\u0026lt; \u0026#34;sp0: \u0026#34; \u0026lt;\u0026lt; sp0.use_count() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } // sp0: 0 // Cukoo() // age: 24 // sp1: 1 // sp2: 2 // sp0: 3 // sp0: 1 // ~Cukoo() ","date":"2024-03-11","externalUrl":null,"permalink":"/posts/%E6%89%8B%E5%86%99shared-ptr/","section":"文章","summary":"","title":"手写 shared_ptr","type":"posts"},{"content":"以下是我对常见的内部排序算法的简单总结，仅供自己复习之用，不涉及详细的算法讲解。\n插入排序 #\r插入排序是一种简单直观的排序方法，其基本思想是每次将一个待排序的元素按其关键字大小插入到前面已排好序的子表中，直到全部元素插入完成。\n由插入排序的思想可以引申出三个重要的排序算法：直接插入排序、折半插入排序、希尔排序。\n直接插入排序 #\r算法思想\n初始时将第一个元素视为已排好序的子表，然后依次将后面的元素插入到已排好序的子表中。\n算法实现\nvoid StraightInsertionSort(vector\u0026lt;int\u0026gt;\u0026amp; nums) { // 将各元素插入到前面排好序的子表中 for (int i = 1; i \u0026lt; nums.size(); ++i) { int temp = nums[i]; int j; // 前面排好序的子表中比待插入元素大的都要向后挪一个位置 for (j = i - 1; j \u0026gt;= 0 \u0026amp;\u0026amp; nums[j] \u0026gt; temp; --j) nums[j + 1] = nums[j]; // 将待插入元素复制到插入位置 nums[j + 1] = temp; } } 算法分析\n空间复杂度$O(1)$ 时间复杂度$O(n^2)$ 稳定性：稳定 折半插入排序 #\r算法思想\n当排序表是顺序表时，可以对直接插入排序算法做如下改进：使用折半查找来确定待插入位置，然后再统一地向后移动元素。\n算法实现\nvoid BinaryInsertionSort(vector\u0026lt;int\u0026gt;\u0026amp; nums) { for (int i = 1; i \u0026lt; nums.size(); ++i) { int temp = nums[i]; // 二分查找插入位置 int left = 0; int right = i - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] \u0026lt;= temp) left = mid + 1; else right = mid - 1; } // 从插入位置开始往后的元素都要向后挪一个位置 for (int j = i - 1; j \u0026gt;= left; --j) nums[j + 1] = nums[j]; // 将待插入元素复制到插入位置 nums[left] = temp; } } 算法分析\n空间复杂度$O(1)$ 时间复杂度$O(n^2)$：仅减少了比较元素的次数，而移动元素的次数并未改变 稳定性：稳定 希尔排序 #\r算法思想\n直接插入排序算法的时间复杂度为$O(n^2)$，但若待排表为“正序”时，其时间复杂度可提高至$O(n)$，由此可见它更适用于基本有序的排序表和数据量不大的排序表。希尔排序正是基于这两点分析对直接插入排序进行改进而得来的，又称缩小增量排序。\n希尔排序的基本思想是：先将待排序表分割成若干形如{i, i+d, i+2d, ..., i+kd}的“子表”，即把相隔某个“增量”的元素组成一个子表，对各个子表分别进行直接插入排序。逐步减少增量d，使排序表逐步呈现“基本有序”的情形，最终d = 1，即对全体元素进行一次直接插入排序。\n算法实现\nvoid ShellSort(vector\u0026lt;int\u0026gt;\u0026amp; nums) { for (int d = nums.size() / 2; d \u0026gt;= 1; d /= 2) { // 步长变化 // 从子表的第二个元素开始，进行直接插入排序 for (int i = d; i \u0026lt; nums.size(); ++i) { int temp = nums[i]; int j; for (j = i - d; j \u0026gt;= 0 \u0026amp;\u0026amp; nums[j] \u0026gt; temp; j -= d) nums[j + d] = nums[j]; nums[j + d] = temp; } } } 算法分析\n空间复杂度$O(1)$ 时间复杂度：比直接插入排序要低，具体多少未知，这是数学上尚未解决的难题 稳定性：不稳定，当相同的元素被划分到不同的子表时，可能会改变它们之间的相对次序 交换排序 #\r冒泡排序 #\r算法思想\n从后往前（或从前往后）两两比较相邻元素值，若为逆序，则交换它们。我们称这是一趟冒泡，每趟冒泡的结果会将最小的元素交换到待排序表的第一个位置。下一趟冒泡时，前一趟确定的最小元素（或最大元素）不再参与比较。这样最多做n-1趟就能完成排序。\n算法实现\nvoid BubbleSort(vector\u0026lt;int\u0026gt;\u0026amp; nums) { for (int i = 0; i \u0026lt; nums.size() - 1; ++i) { bool swapped = false; // 记录本趟冒泡是否发生过交换 for (int j = nums.size() - 1; j \u0026gt; i; --j) { if (nums[j - 1] \u0026gt; nums[j]) { swap(nums[j - 1], nums[j]); swapped = true; } } if (swapped == false) // 没有发生过交换，说明已经有序 break; } } 算法分析\n空间复杂度$O(1)$ 时间复杂度$O(n^2)$ 稳定性：稳定，相邻元素相等时，不会发生交换 快速排序 #\r算法思想\n在待排序表{1...n}中任取一个元素作为枢轴pivot，通过一趟排序将待排序表划分为独立的两部分{1...k-1}和{k+1...n}，使得{1...k-1}中的所有元素小于枢轴pivot，{k+1...n}中所有元素大于等于枢轴pivot，则枢轴pivot放在了其最终位置k上，这个过程称为一趟快速排序（或一次划分）。然后分别递归地对两个子表重复上述过程，直至子表内只有一个元素或为空为止，即所有元素都放在了其最终位置上。\n算法实现\n// 对区间[left, right]内的元素进行快速排序 void QuickSort(vector\u0026lt;int\u0026gt;\u0026amp; nums, int left, int right) { if (left \u0026gt;= right) return; int pivot_idx = Partition(nums, left, right); // 进行一次划分 QuickSort(nums, left, pivot_idx - 1); // 对左半部分进行快速排序 QuickSort(nums, pivot_idx + 1, right); // 对右半部分进行快速排序 } // 对区间[left, right]内的元素进行划分，返回枢轴下标 int Partition(vector\u0026lt;int\u0026gt;\u0026amp; nums, int left, int right) { int pivot = nums[left]; // 选取首元素作为枢轴 while (left \u0026lt; right) { // 从右往左扫描，将小于枢轴的元素放到左边 while (left \u0026lt; right \u0026amp;\u0026amp; nums[right] \u0026gt;= pivot) --right; nums[left] = nums[right]; // 从左往右扫描，将大于等于枢轴的元素放到右边 while (left \u0026lt; right \u0026amp;\u0026amp; nums[left] \u0026lt; pivot) ++left; nums[right] = nums[left]; } nums[left] = pivot; // 将枢轴放到最终位置上 return left; } 算法分析\n空间复杂度$O(log_2n)$：快速排序的递归调用过程可以看成是一棵结点数为n的二叉树，空间复杂度取决于树的深度，平均空间复杂度与最好空间复杂度接近 时间复杂度$O(nlog_2n)$：在树的每一层中的时间复杂度不超过$O(n)$，时间复杂度为$O(n×树的深度)$ 稳定性：不稳定 选择排序 #\r选择排序的基本思想是每次从待排序表中选出最小（或最大）的元素，加入到有序子表中。\n简单选择排序 #\r算法思想\n通过遍历的方式，从待排序表中最小（或最大）的元素，放入有序子表的末尾（即与待排序表的首元素交换），直至待排序表为空。\n算法实现\nvoid SimpleSelectionSort(vector\u0026lt;int\u0026gt;\u0026amp; nums) { for (int i = 0; i \u0026lt; nums.size() - 1; ++i) { int minIndex = i; // 记录最小元素下标 for (int j = i + 1; j \u0026lt; nums.size(); ++j) { if (nums[j] \u0026lt; nums[minIndex]) minIndex = j; } if (minIndex != i) swap(nums[i], nums[minIndex]); } } 算法分析\n空间复杂度$O(1)$ 时间复杂度$O(n^2)$ 稳定性：不稳定，例如{2,2',1}排序后会变为{1,2',2} 堆排序 #\r算法思想\n在堆这种数据结构中，最小（或最大）的元素位于堆顶。因此，只要始终将待排序表维护成堆，然后每次都将堆顶元素加入到有序子表中，就能实现排序。\n算法实现\n以大根堆为例\n初始建堆\n将待排序表视为以数组形式存储的完全二叉树，从后往前依次对所有分支结点进行调整，因为只有分支结点才有可能不满足大根堆的性质，且从后往前依次进行调整可以复用前面的处理结果，有点像动态规划的味道。\n调整的具体做法是：如果不满足大根堆性质，则将当前结点与较大的孩子交换。这样做的结果是把一个较小的结点交换到下面，这可能会破坏下一级的堆，因此要采用相同的方法继续调整。（“小元素不断下坠”）\n将堆顶元素加入到有序子表\n这一步是通过将堆顶元素与堆底元素互换实现的。\n新堆顶元素不断下坠\n堆顶元素发生改变，大根堆的性质可能遭到破坏。因此需要进行调整，也就是让堆顶元素不断下坠。\nvoid HeapSort(vector\u0026lt;int\u0026gt;\u0026amp; nums) { BuildMaxHeap(nums); // 初始建堆 for (int i = nums.size() - 1; i \u0026gt; 0; i--) { // n-1 趟交换和调整 swap(nums[i], nums[0]); HeadAdjust(nums, 0, i); } } void BuildMaxHeap(vector\u0026lt;int\u0026gt;\u0026amp; nums) { for (int i = nums.size() / 2 - 1; i \u0026gt;= 0; --i) HeadAdjust(nums, i, nums.size()); } // 以 i 为根结点的树仅在根结点位置不满足大根堆性质 // 对根结点 i 的位置进行调整 // 该过程可形象地描述为“根结点不断下坠” void HeadAdjust(vector\u0026lt;int\u0026gt;\u0026amp; nums, int i, int end) { // 将 nums[i] 的位置逐步向下调整，直至以它为根的子树符合大根堆性质为止 for (int j = 2 * i + 1; j \u0026lt; end; j = j * 2 + 1) { if (j \u0026lt; end - 1 \u0026amp;\u0026amp; nums[j + 1] \u0026gt; nums[j]) ++j; if (nums[i] \u0026gt;= nums[j]) break; std::swap(nums[i], nums[j]); i = j; } } 算法分析\n空间复杂度$O(1)$ 时间复杂度$O(nlog_2n)$：建堆的时间复杂度为$O(n)$（具体计算较复杂），每次调整的时间复杂度与下坠层数有关，但不超过$O(log_2n)$，共有 n-1 次调整 稳定性：不稳定 归并排序和基数排序 #\r归并排序 #\r算法思想\n将待排序表视为n个只含 1 个元素的有序子表，然后两两归并，合并成一个更大的有序表，直到合并成一个长度为n的有序表为止。\n算法实现\nvector\u0026lt;int\u0026gt; tmp; // 对区间[left, right]内的元素进行归并排序 void MergeSort(vector\u0026lt;int\u0026gt;\u0026amp; nums, int left, int right) { if (left \u0026gt;= right) return; int mid = left + (right - left) / 2; // 从中间划分 MergeSort(nums, left, mid); // 对左半部分进行归并排序 MergeSort(nums, mid + 1, right); // 对右半部分进行归并排序 Merge(nums, left, mid, right); // 左半部分和右半部分各自有序，将二者归并 } // 区间[left, mid]和区间[mid + 1, right]各自有序，将二者归并 void Merge(vector\u0026lt;int\u0026gt;\u0026amp; nums, int left, int mid, int right) { // 对区间内的元素进行备份 tmp.resize(nums.size(), 0); std::copy(nums.begin() + left, nums.begin() + right + 1, tmp.begin() + left); // 三指针，依次取较小值 int i = left; int j = mid + 1; int k = left; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= right) { if (tmp[i] \u0026lt;= tmp[j]) nums[k++] = tmp[i++]; else nums[k++] = tmp[j++]; } // 将较长有序表中剩余的元素依次取完 while (i \u0026lt;= mid) nums[k++] = tmp[i++]; while (j \u0026lt;= right) nums[k++] = tmp[j++]; } 算法分析\n空间复杂度$O(n)$：辅助数组所需空间为$O(n)$。归并排序的递归调用过程可以看成是一棵最后一层结点数为 n 的二叉树，递归调用栈所需空间$O(log_2n)$ 时间复杂度$O(nlog_2n)$：归并的趟数与树高有关，为$O(log_2n)$，每趟归并的时间复杂度为$O(n)$ 稳定性：稳定，归并操作可以不改变相同元素的相对次序 基数排序 #\r算法思想\n假设元素的关键字可拆分为 d 个位（或称“组”），每个关键字位可能取得有限的 r 个值，按照关键字位权重递增的次序，做 d 趟“分配”和“收集”，这个过程中需要建立 r 个队列。\n分配：顺序扫描各个元素，若当前处理的关键字位为 x，则将其插入到队列 Qx中 收集：令各个队列中的元素依次出队并链接 算法实现\n略\n算法分析\n空间复杂度$O(r)$：需要 r 个辅助队列 时间复杂度$O(d(n+r))$：需要进行 d 趟分配和收集，一趟分配需要$O(n)$，一趟收集需要$O(r)$ 总结 #\r在上述排序算法中，\n时间复杂度为$O(nlog_2n)$的算法一般都不稳定，其中只有归并排序是稳定的 时间复杂度为$O(n^2)$的算法一般都稳定，其中只有简单选择排序是不稳定的 希尔排序、折半插入排序不适用于链表，堆排序不建议使用链表实现，其余排序算法均适用于链表。 （完）\n","date":"2024-02-26","externalUrl":null,"permalink":"/posts/%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/","section":"文章","summary":"","title":"常见的排序算法总结","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"分类","summary":"","title":"分类","type":"categories"},{"content":"","externalUrl":null,"permalink":"/about/","section":"关于","summary":"","title":"关于","type":"about"}]