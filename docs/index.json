[{"content":"手写shared_ptr是面试的常考点，提前准备一下吧。\nshared_ptr的关键特性 首先明确shared_ptr的关键特性：\n允许多个shared_ptr指向同一个对象 每个shared_ptr都有一个关联的引用计数，用于记录总共有多少个shared_ptr指向相同的对象 一旦一个shared_ptr所关联的引用计数变为0，它就会自动释放自己所管理的对象 代码思路 显然，最关键的就是要实现引用计数这个机制，大致思路如下：\n在堆中创建一个整型对象作为引用计数 在拷贝或赋值时修改引用计数 在析构函数中递减引用计数，并考察它是否变为0，如果变为0，则释放所指向的对象以及引用计数对象 代码实现 #include \u0026lt;iostream\u0026gt; template \u0026lt;typename T\u0026gt; class TinySharedPtr { public: // 构造函数 explicit TinySharedPtr(T* ptr = nullptr) : ptr_(ptr) { if (ptr_) count_ = new int(1); } // 拷贝构造函数 TinySharedPtr(const TinySharedPtr\u0026amp; other) : ptr_(other.ptr_), count_(other.count_) { if (count_) ++*count_; } // 拷贝赋值运算符 TinySharedPtr\u0026amp; operator=(TinySharedPtr other) { std::swap(ptr_, other.ptr_); std::swap(count_, other.count_); return *this; } // 析构函数 ~TinySharedPtr() { if (count_ \u0026amp;\u0026amp; --(*count_) == 0) { delete ptr_; delete count_; } } T* get() { return ptr_; } T* operator-\u0026gt;() { return ptr_; } T\u0026amp; operator*() { return *ptr_; } int use_count() { return count_ ? *count_ : 0; } private: T* ptr_ = nullptr; int* count_ = nullptr; }; struct Cukoo { Cukoo() { puts(\u0026#34;Cukoo()\u0026#34;); } ~Cukoo() { puts(\u0026#34;~Cukoo()\u0026#34;); } int age = 24; }; int main() { TinySharedPtr\u0026lt;Cukoo\u0026gt; sp0; std::cout \u0026lt;\u0026lt; \u0026#34;sp0: \u0026#34; \u0026lt;\u0026lt; sp0.use_count() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; { TinySharedPtr\u0026lt;Cukoo\u0026gt; sp1(new Cukoo()); std::cout \u0026lt;\u0026lt; \u0026#34;age: \u0026#34; \u0026lt;\u0026lt; sp1-\u0026gt;age \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;sp1: \u0026#34; \u0026lt;\u0026lt; sp1.use_count() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; TinySharedPtr\u0026lt;Cukoo\u0026gt; sp2(sp1); std::cout \u0026lt;\u0026lt; \u0026#34;sp2: \u0026#34; \u0026lt;\u0026lt; sp2.use_count() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; sp0 = sp2; std::cout \u0026lt;\u0026lt; \u0026#34;sp0: \u0026#34; \u0026lt;\u0026lt; sp2.use_count() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } std::cout \u0026lt;\u0026lt; \u0026#34;sp0: \u0026#34; \u0026lt;\u0026lt; sp0.use_count() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } // sp0: 0 // Cukoo() // age: 24 // sp1: 1 // sp2: 2 // sp0: 3 // sp0: 1 // ~Cukoo() ","permalink":"https://cukoohhh.cn/posts/%E6%89%8B%E5%86%99shared_ptr/","summary":"手写shared_ptr是面试的常考点，提前准备一下吧。\nshared_ptr的关键特性 首先明确shared_ptr的关键特性：\n允许多个shared_ptr指向同一个对象 每个shared_ptr都有一个关联的引用计数，用于记录总共有多少个shared_ptr指向相同的对象 一旦一个shared_ptr所关联的引用计数变为0，它就会自动释放自己所管理的对象 代码思路 显然，最关键的就是要实现引用计数这个机制，大致思路如下：\n在堆中创建一个整型对象作为引用计数 在拷贝或赋值时修改引用计数 在析构函数中递减引用计数，并考察它是否变为0，如果变为0，则释放所指向的对象以及引用计数对象 代码实现 #include \u0026lt;iostream\u0026gt; template \u0026lt;typename T\u0026gt; class TinySharedPtr { public: // 构造函数 explicit TinySharedPtr(T* ptr = nullptr) : ptr_(ptr) { if (ptr_) count_ = new int(1); } // 拷贝构造函数 TinySharedPtr(const TinySharedPtr\u0026amp; other) : ptr_(other.ptr_), count_(other.count_) { if (count_) ++*count_; } // 拷贝赋值运算符 TinySharedPtr\u0026amp; operator=(TinySharedPtr other) { std::swap(ptr_, other.ptr_); std::swap(count_, other.count_); return *this; } // 析构函数 ~TinySharedPtr() { if (count_ \u0026amp;\u0026amp; --(*count_) == 0) { delete ptr_; delete count_; } } T* get() { return ptr_; } T* operator-\u0026gt;() { return ptr_; } T\u0026amp; operator*() { return *ptr_; } int use_count() { return count_ ?","title":"手写shared_ptr"},{"content":"内部排序算法是面试中的常考点，其中快速排序和归并排序是重点。\n以下是我对常见的内部排序算法的简单总结，仅供自己复习之用，不涉及详细的算法讲解。\n插入排序 插入排序是一种简单直观的排序方法，其基本思想是每次将一个待排序的元素按其关键字大小插入到前面已排好序的子表中，直到全部元素插入完成。\n由插入排序的思想可以引申出三个重要的排序算法：直接插入排序、折半插入排序、希尔排序。\n直接插入排序 算法思想\n初始时将第一个元素视为已排好序的子表，然后依次将后面的元素插入到已排好序的子表中。\n算法实现\nvoid StraightInsertionSort(vector\u0026lt;int\u0026gt;\u0026amp; nums) { // 将各元素插入到前面排好序的子表中 for (int i = 1; i \u0026lt; nums.size(); ++i) { int temp = nums[i]; int j; // 前面排好序的子表中比待插入元素大的都要向后挪一个位置 for (j = i - 1; j \u0026gt;= 0 \u0026amp;\u0026amp; nums[j] \u0026gt; temp; --j) nums[j + 1] = nums[j]; // 将待插入元素复制到插入位置 nums[j + 1] = temp; } } 算法分析\n空间复杂度$O(1)$ 时间复杂度$O(n^2)$ 稳定性：稳定 折半插入排序 算法思想\n当排序表是顺序表时，可以对直接插入排序算法做如下改进：使用折半查找来确定待插入位置，然后再统一地向后移动元素。\n算法实现\nvoid BinaryInsertionSort(vector\u0026lt;int\u0026gt;\u0026amp; nums) { for (int i = 1; i \u0026lt; nums.size(); ++i) { int temp = nums[i]; // 二分查找插入位置 int left = 0; int right = i - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (temp \u0026lt; nums[mid]) right = mid - 1; else left = mid + 1; } // 从插入位置开始往后的元素都要向后挪一个位置 for (int j = i - 1; j \u0026gt;= left; --j) nums[j + 1] = nums[j]; // 将待插入元素复制到插入位置 nums[left] = temp; } } 算法分析\n空间复杂度$O(1)$ 时间复杂度$O(n^2)$：仅减少了比较元素的次数，而移动元素的次数并未改变 稳定性：稳定 希尔排序 算法思想\n直接插入排序算法的时间复杂度为O(n^2)，但若待排表为“正序”时，其时间复杂度可提高至O(n)，由此可见它更适用于基本有序的排序表和数据量不大的排序表。希尔排序正是基于这两点分析对直接插入排序进行改进而得来的，又称缩小增量排序。\n希尔排序的基本思想是：先将待排序表分割成若干形如{i, i+d, i+2d, ..., i+kd}的“子表”，即把相隔某个“增量”的元素组成一个子表，对各个子表分别进行直接插入排序。逐步减少增量d，使排序表逐步呈现“基本有序”的情形，最终d=1，即对全体元素进行一次直接插入排序。\n算法实现\nvoid ShellSort(vector\u0026lt;int\u0026gt;\u0026amp; nums) { for (int d = nums.size() / 2; d \u0026gt;= 1; d /= 2) { // 步长变化 // 从子表的第二个元素开始，进行直接插入排序 for (int i = d; i \u0026lt; nums.size(); ++i) { int temp = nums[i]; int j; for (j = i - d; j \u0026gt;= 0 \u0026amp;\u0026amp; nums[j] \u0026gt; temp; j -= d) nums[j + d] = nums[j]; nums[j + d] = temp; } } } 算法分析\n空间复杂度$O(1)$ 时间复杂度：比直接插入排序要低，具体多少未知，这是数学上尚未解决的难题 稳定性：不稳定，当相同的元素被划分到不同的子表时，可能会改变它们之间的相对次序 交换排序 冒泡排序 算法思想\n从后往前（或从前往后）两两比较相邻元素值，若为逆序，则交换它们。我们称这是一趟冒泡，每趟冒泡的结果会将最小的元素交换到待排序表的第一个位置。下一趟冒泡时，前一趟确定的最小元素（或最大元素）不再参与比较。这样最多做n-1趟就能完成排序。\n算法实现\nvoid BubbleSort(vector\u0026lt;int\u0026gt;\u0026amp; nums) { for (int i = 0; i \u0026lt; nums.size() - 1; ++i) { bool swaped = false; // 记录本趟冒泡是否发生过交换 for (int j = nums.size() - 1; j \u0026gt; i; --j) { if (nums[j - 1] \u0026gt; nums[j]) { swap(nums[j - 1], nums[j]); swaped = true; } } if (swaped == false) // 没有发生过交换，说明已经有序 return; } } 算法分析\n空间复杂度$O(1)$ 时间复杂度$O(n^2)$ 稳定性：稳定，相邻元素相等时，不会发生交换 快速排序 算法思想\n在待排序表{1...n}中任取一个元素作为枢轴pivot，通过一趟排序将待排序表划分为独立的两部分{1...k-1}和{k+1...n}，使得{1...k-1}中的所有元素小于枢轴pivot，{k+1...n}中所有元素大于等于枢轴pivot，则枢轴pivot放在了其最终位置k上，这个过程称为一趟快速排序（或一次划分）。然后分别递归地对两个子表重复上述过程，直至子表内只有一个元素或为空为止，即所有元素都放在了其最终位置上。\n算法实现\nvoid QuickSort(vector\u0026lt;int\u0026gt;\u0026amp; nums, int left, int right) { if (left \u0026lt; right) { // 递归跳出的条件 int privot_index = Partition(nums, left, right); // 划分 // 分别对两个子表进行递归排序 QuickSort(nums, left, privot_index - 1); QuickSort(nums, privot_index + 1, right); } } int Partition(vector\u0026lt;int\u0026gt;\u0026amp; nums, int left, int right) { int privot = nums[left]; // 将第一个元素作为枢轴 while (left \u0026lt; right) { // 循环跳出条件 // 将小于枢轴的元素移动到左边 while (left \u0026lt; right \u0026amp;\u0026amp; nums[right] \u0026gt;= privot) --right; nums[left] = nums[right]; // 将大于等于枢轴的元素移动到右边 while (left \u0026lt; right \u0026amp;\u0026amp; nums[left] \u0026lt; privot) ++left; nums[right] = nums[left]; } nums[left] = privot; // 将枢轴元素放到最终位置 return left; } 算法分析\n空间复杂度$O(log_2n)$：快速排序的递归调用过程可以看成是一棵结点数为n的二叉树，空间复杂度取决于树的深度，平均空间复杂度与最好空间复杂度接近 时间复杂度$O(nlog_2n)$：在树的每一层中的时间复杂度不超过$O(n)$，时间复杂度为$O(n×树的深度)$ 稳定性：不稳定 选择排序 选择排序的基本思想是每次从待排序表中选出最小（或最大）的元素，加入到有序子表中。\n简单选择排序 算法思想\n通过遍历的方式，从待排序表中最小（或最大）的元素，放入有序子表的末尾（即与待排序表的首元素交换），直至待排序表为空。\n算法实现\nvoid SimpleSelectionSort(vector\u0026lt;int\u0026gt;\u0026amp; nums) { for (int i = 0; i \u0026lt; nums.size() - 1; ++i) { int minIndex = i; // 记录最小元素下标 for (int j = i + 1; j \u0026lt; nums.size(); ++j) { if (nums[j] \u0026lt; nums[minIndex]) minIndex = j; } if (minIndex != i) swap(nums[i], nums[minIndex]); } } 算法分析\n空间复杂度$O(1)$ 时间复杂度$O(n^2)$ 稳定性：不稳定，例如{2,2',1}排序后会变为{1,2',2} 堆排序 算法思想\n在堆这种数据结构中，最小（或最大）的元素位于堆顶。因此，只要始终将待排序表维护成堆，然后每次都将堆顶元素加入到有序子表中，就能实现排序。\n算法实现\n以大根堆为例\n初始建堆\n将待排序表视为以数组形式存储的完全二叉树，从后往前检查所有分支节点是否满足大根堆的性质。如果不满足，则进行调整，也就是将当前结点与较大的孩子交换。由于把一个较小的结点交换到下面，因此可能会破坏下一级的堆，则采用相同的方法继续调整。（“小元素不断下坠”）\n将堆顶元素加入到有序子表\n这一步是通过将堆顶元素与堆底元素互换实现的。\n新堆顶元素不断下坠\n堆顶元素发生改变，大根堆的性质可能遭到破坏。因此需要进行调整，也就是让堆顶元素不断下坠。\nvoid HeapSort(vector\u0026lt;int\u0026gt;\u0026amp; nums) { // 将待排序表转换为以数组形式存储的完全二叉树（根结点下标为1） nums.resize(nums.size() + 1); for (int i = nums.size() - 1; i \u0026gt; 0; --i) nums[i] = nums[i - 1]; // 堆排序 BuildMaxHeap(nums); // 初始建堆 for (int i = nums.size() - 1; i \u0026gt; 1; i--) { // n-1趟交换和调整 swap(nums[i], nums[1]); HeadAdjust(nums, 1, i); } // 复原待排序表 for (int i = 0; i \u0026lt; nums.size() - 1; ++i) nums[i] = nums[i + 1]; nums.resize(nums.size() - 1); } void BuildMaxHeap(vector\u0026lt;int\u0026gt;\u0026amp; nums) { for (int i = nums.size() / 2; i \u0026gt; 0; --i) HeadAdjust(nums, i, nums.size()); } // 将以k为根结点的树调整为大根堆，也就是将下标为k的结点不断下坠 void HeadAdjust(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k, int end) { nums[0] = nums[k]; // nums[0]用于暂存根结点的值 // 寻找适合放置根结点的位置k for (int i = 2 * k; i \u0026lt; end; i *= 2) { if (i \u0026lt; end - 1 \u0026amp;\u0026amp; nums[i] \u0026lt; nums[i + 1]) ++i; if (nums[0] \u0026gt;= nums[i]) // 如果将根结点放到位置k，是否符合大根堆的性质 break; else { nums[k] = nums[i]; k = i; } } nums[k] = nums[0]; // 将根结点放到位置k } 算法分析\n空间复杂度$O(1)$ 时间复杂度$O(nlog_2n)$：建堆的时间复杂度为$O(n)$（具体计算较复杂），每次调整的时间复杂度与下坠层数有关，但不超过$O(log_2n)$，共有n-1次调整 稳定性：不稳定 归并排序和基数排序 归并排序 算法思想\n将待排序表视为n个只含1个元素的有序子表，然后两两归并，合并成一个更大的有序表，直到合并成一个长度为n的有序表为止。\n算法实现\nvector\u0026lt;int\u0026gt; temp; void MergeSort(vector\u0026lt;int\u0026gt;\u0026amp; nums, int left, int right) { temp.resize(nums.size(), 0); if (left \u0026lt; right) { int mid = left + (right - left) / 2; // 从中间划分 MergeSort(nums, left, mid); // 对左半部分进行归并排序 MergeSort(nums, mid + 1, right); // 对右半部分进行归并排序 Merge(nums, left, mid, right); // 归并 } } // [left, mid]和[mid + 1, right]各自有序，将二者归并 void Merge(vector\u0026lt;int\u0026gt;\u0026amp; nums, int left, int mid, int right) { // 将区间内nums的元素拷贝到temp中 copy(nums.begin() + left, nums.begin() + right + 1, temp.begin() + left); // 三指针，依次取较小值 int i, j, k; for (i = left, j = mid + 1, k = left; i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= right; ++k) { if (temp[i] \u0026lt;= temp[j]) nums[k] = temp[i++]; else nums[k] = temp[j++]; } // 将较长有序表中剩余的元素依次取完 while (i \u0026lt;= mid) nums[k++] = temp[i++]; while (j \u0026lt;= right) nums[k++] = temp[j++]; } 算法分析\n空间复杂度$O(n)$：辅助数组所需空间为$O(n)$。归并排序的递归调用过程可以看成是一棵最后一层结点数为n的二叉树，递归调用栈所需空间$O(log_2n)$ 时间复杂度$O(nlog_2n)$：归并的趟数与树高有关，为$O(log_2n)$，每趟归并的时间复杂度为$O(n)$ 稳定性：稳定，归并操作可以不改变相同元素的相对次序 基数排序 算法思想\n假设元素的关键字可拆分为d个位（或称“组”），每个关键字位可能取得有限的r个值，按照关键字位权重递增的次序，做d趟“分配”和“收集”，这个过程中需要建立r个队列。\n分配：顺序扫描各个元素，若当前处理的关键字位为x，则将其插入到队列Q~x~中 收集：令各个队列中的元素依次出队并链接 算法实现\n略\n算法分析\n空间复杂度$O(r)$：需要r个辅助队列 时间复杂度$O(d(n+r))$：需要进行d趟分配和收集，一趟分配需要$O(n)$，一趟收集需要$O(r)$ 总结 （完）\n","permalink":"https://cukoohhh.cn/posts/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/","summary":"内部排序算法是面试中的常考点，其中快速排序和归并排序是重点。\n以下是我对常见的内部排序算法的简单总结，仅供自己复习之用，不涉及详细的算法讲解。\n插入排序 插入排序是一种简单直观的排序方法，其基本思想是每次将一个待排序的元素按其关键字大小插入到前面已排好序的子表中，直到全部元素插入完成。\n由插入排序的思想可以引申出三个重要的排序算法：直接插入排序、折半插入排序、希尔排序。\n直接插入排序 算法思想\n初始时将第一个元素视为已排好序的子表，然后依次将后面的元素插入到已排好序的子表中。\n算法实现\nvoid StraightInsertionSort(vector\u0026lt;int\u0026gt;\u0026amp; nums) { // 将各元素插入到前面排好序的子表中 for (int i = 1; i \u0026lt; nums.size(); ++i) { int temp = nums[i]; int j; // 前面排好序的子表中比待插入元素大的都要向后挪一个位置 for (j = i - 1; j \u0026gt;= 0 \u0026amp;\u0026amp; nums[j] \u0026gt; temp; --j) nums[j + 1] = nums[j]; // 将待插入元素复制到插入位置 nums[j + 1] = temp; } } 算法分析\n空间复杂度$O(1)$ 时间复杂度$O(n^2)$ 稳定性：稳定 折半插入排序 算法思想\n当排序表是顺序表时，可以对直接插入排序算法做如下改进：使用折半查找来确定待插入位置，然后再统一地向后移动元素。\n算法实现\nvoid BinaryInsertionSort(vector\u0026lt;int\u0026gt;\u0026amp; nums) { for (int i = 1; i \u0026lt; nums.","title":"常见的内部排序算法总结"},{"content":"前言 在开发中，我们经常会使用到第三方库，以避免造轮子，从而提高开发效率。在C++中使用第三方库，首先需要进行以下步骤：\n获取库文件和头文件 告知编译器头文件的所在目录 告知编译器库文件的所在目录 告知编译器要链接的库文件 库文件的获取主要有两种方式：\n库厂商有提供库文件，自行选择所需版本下载即可 库厂商没有提供库文件，但开放了源代码，此时就需要自己根据源代码进行编译，得到所需的库文件 所有的库文件都提供有相应的头文件作为调用它的接口。换言之，我们在拿到库文件的同时，也拿到了头文件。\n搭建使用第三方库的C++开发环境的核心步骤是固定的，也就是上述提到的4个步骤，但具体操作因平台和开发工具而异。\n前段时间一直忙于软著的开发，其中涉及到了gdal库的调用。以下将分享我个人在搭建gdal C++开发环境时所做的记录，希望能够帮到有需要的人。\n基于vcpkg的gdal库编译 vcpkg是微软推出的开源的C/C++库管理器，它能够自动为我们处理库编译所需的各种依赖关系，就像是Python中的miniconda。\n下载vcpkg\n使用git-bash中执行以下命令，以下载vcpkg。\ngit clone https://github.com/microsoft/vcpkg.git 如果你没有git，打开上述命令中的网址，点击\u0026quot;Code\u0026quot;-\u0026ldquo;Download ZIP\u0026rdquo;，下载后解压即可。\n使用vcpkg进行gdal库编译\n在vcpkg文件夹的上级目录中，使用命令提示符(cmd)依次执行以下命令。\n.\\vcpkg\\bootstrap-vcpkg.bat .\\vcpkg\\vcpkg install gdal:x64-windows 接下来，可以喝杯茶、摸会儿鱼，等待编译完成。编译耗时因电脑性能而异，在我的电脑中，耗时42分钟。\n查看库文件和头文件\n进入vcpkg/installed/x64-windows\nbin和lib文件夹中分别存放着适用于Relese模式下的动态库文件(.dll)和静态库（也可能是动态库的导入库）文件(.lib) debug中的bin和lib文件夹分别存放着适用于Debug模式下的动态库文件(.dll)和静态库（也可能是动态库的导入库）文件(.lib) include文件夹中存放着头文件 以上就是基于vcpkg进行gdal库编译的操作过程，本文没有对相关命令进行讲解，更多详细信息请参考vcpkg的GitHub仓库中的README.md。\nVisual Studio项目属性设置 打开Visual Studio，创建一个C++空项目，在项目中添加一个.cpp文件。随后，在项目右键菜单中点击“属性”，将弹出如下图所示的“[项目名]属性页”。\n在设置项目属性之前，我们可以先将库文件和头文件放到项目文件夹中，这样在后续的项目设置中，就可以尽量使用相对路径。这样做的好处是，当我们将整个项目打包，放到其他电脑中打开时，就不用修改项目属性了。\n在解决方案目录下新建一个名为\u0026quot;gdal\u0026quot;的文件夹 将vcpkg/installed/x64-windows下的bin、debug、include、lib文件夹拷贝至刚刚新建的gdal文件夹中 接下来我们正式开始进行项目属性设置（以Debug配置为例）\n设置附加包含目录 - 告知编译器头文件的所在目录\n在\u0026quot;C/C++\u0026quot;-\u0026ldquo;常规\u0026rdquo;-\u0026ldquo;附加包含目录\u0026quot;中填写$(SolutionDir)gdal\\include\n设置附加库目录 - 告知编译器.lib库文件的所在目录\n在\u0026quot;链接器\u0026rdquo;-\u0026ldquo;常规\u0026rdquo;-\u0026ldquo;附加库目录\u0026quot;中填写$(SolutionDir)gdal\\debug\\lib\n设置环境 - 告知编译器.dll库文件的所在目录\n在\u0026quot;调试\u0026rdquo;-\u0026ldquo;环境\u0026quot;中填写Path = $(SolutionDir)gdal\\debug\\bin\n设置附加依赖项 - 告知编译器要链接的库文件\n在\u0026quot;链接器\u0026rdquo;-\u0026ldquo;输入\u0026rdquo;-\u0026ldquo;附加依赖项\u0026quot;中填写gdald.lib\n最后点击确定，项目属性设置完毕。\n测试 在main.cpp文件中输入如下代码，注意要将第7行中的文件路径改成你自己的，第13行中的函数实参也要做相应的修改。\n#include \u0026lt;ogrsf_frmts.h\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int main() { GDALAllRegister();\t// 自动注册所有驱动，只能读不能写 GDALDataset* poDS = static_cast\u0026lt;GDALDataset*\u0026gt;(GDALOpenEx( \u0026#34;./data/point.shp\u0026#34;, GDAL_OF_VECTOR, nullptr, nullptr, nullptr));\t// 创建Dataset if (poDS == nullptr) { cout \u0026lt;\u0026lt; \u0026#34;open failed.\u0026#34; \u0026lt;\u0026lt; endl; exit(1); } OGRLayer* poLayer = poDS-\u0026gt;GetLayerByName(\u0026#34;point\u0026#34;);\t// 获取Layer，shapefile格式的LayerName就是文件名 OGRFeatureDefn* poFDefn = poLayer-\u0026gt;GetLayerDefn();\t// 获取Layer的定义（包含Geometry和Field的定义） poLayer-\u0026gt;ResetReading();\t// 重置游标 OGRFeature* poFeature; while ((poFeature = poLayer-\u0026gt;GetNextFeature()) != nullptr) {\t// 输出Layer中所有Feature的字段值 for (int iField = 0; iField \u0026lt; poFDefn-\u0026gt;GetFieldCount(); ++iField) { OGRFieldDefn* poFieldDefn = poFDefn-\u0026gt;GetFieldDefn(iField); switch (poFieldDefn-\u0026gt;GetType()) { case OFTInteger: printf(\u0026#34;%d,\u0026#34;, poFeature-\u0026gt;GetFieldAsInteger(iField)); break; case OFTInteger64: printf(CPL_FRMT_GIB \u0026#34;,\u0026#34;, poFeature-\u0026gt;GetFieldAsInteger64(iField)); break; case OFTReal: printf(\u0026#34;%.3f,\u0026#34;, poFeature-\u0026gt;GetFieldAsDouble(iField)); break; case OFTString: printf(\u0026#34;%s,\u0026#34;, poFeature-\u0026gt;GetFieldAsString(iField)); break; default: printf(\u0026#34;%s,\u0026#34;, poFeature-\u0026gt;GetFieldAsString(iField)); break; } } cout \u0026lt;\u0026lt; endl; OGRFeature::DestroyFeature(poFeature);\t// GetNextFeature()返回的是一个对象的拷贝，需要自行销毁 } return 0; } 点击“开始调试”，不出意外的话，程序可以正常运行。\n但是，控制台首行会提示\u0026quot;Cannot find proj.db\u0026rdquo;。所谓的\u0026quot;proj.db\u0026quot;实际存放在vcpkg\\installed\\x64-windows\\share\\proj中，我们可以使用以下两种方式让程序找到它。\n利用名为\u0026quot;PROJ_LIB\u0026quot;的环境变量，指明\u0026quot;proj.db\u0026quot;所在目录\n将\u0026quot;proj.db\u0026quot;拷贝到项目目录以及可执行文件所在目录\n（完）\n","permalink":"https://cukoohhh.cn/posts/gdal-c++%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","summary":"前言 在开发中，我们经常会使用到第三方库，以避免造轮子，从而提高开发效率。在C++中使用第三方库，首先需要进行以下步骤：\n获取库文件和头文件 告知编译器头文件的所在目录 告知编译器库文件的所在目录 告知编译器要链接的库文件 库文件的获取主要有两种方式：\n库厂商有提供库文件，自行选择所需版本下载即可 库厂商没有提供库文件，但开放了源代码，此时就需要自己根据源代码进行编译，得到所需的库文件 所有的库文件都提供有相应的头文件作为调用它的接口。换言之，我们在拿到库文件的同时，也拿到了头文件。\n搭建使用第三方库的C++开发环境的核心步骤是固定的，也就是上述提到的4个步骤，但具体操作因平台和开发工具而异。\n前段时间一直忙于软著的开发，其中涉及到了gdal库的调用。以下将分享我个人在搭建gdal C++开发环境时所做的记录，希望能够帮到有需要的人。\n基于vcpkg的gdal库编译 vcpkg是微软推出的开源的C/C++库管理器，它能够自动为我们处理库编译所需的各种依赖关系，就像是Python中的miniconda。\n下载vcpkg\n使用git-bash中执行以下命令，以下载vcpkg。\ngit clone https://github.com/microsoft/vcpkg.git 如果你没有git，打开上述命令中的网址，点击\u0026quot;Code\u0026quot;-\u0026ldquo;Download ZIP\u0026rdquo;，下载后解压即可。\n使用vcpkg进行gdal库编译\n在vcpkg文件夹的上级目录中，使用命令提示符(cmd)依次执行以下命令。\n.\\vcpkg\\bootstrap-vcpkg.bat .\\vcpkg\\vcpkg install gdal:x64-windows 接下来，可以喝杯茶、摸会儿鱼，等待编译完成。编译耗时因电脑性能而异，在我的电脑中，耗时42分钟。\n查看库文件和头文件\n进入vcpkg/installed/x64-windows\nbin和lib文件夹中分别存放着适用于Relese模式下的动态库文件(.dll)和静态库（也可能是动态库的导入库）文件(.lib) debug中的bin和lib文件夹分别存放着适用于Debug模式下的动态库文件(.dll)和静态库（也可能是动态库的导入库）文件(.lib) include文件夹中存放着头文件 以上就是基于vcpkg进行gdal库编译的操作过程，本文没有对相关命令进行讲解，更多详细信息请参考vcpkg的GitHub仓库中的README.md。\nVisual Studio项目属性设置 打开Visual Studio，创建一个C++空项目，在项目中添加一个.cpp文件。随后，在项目右键菜单中点击“属性”，将弹出如下图所示的“[项目名]属性页”。\n在设置项目属性之前，我们可以先将库文件和头文件放到项目文件夹中，这样在后续的项目设置中，就可以尽量使用相对路径。这样做的好处是，当我们将整个项目打包，放到其他电脑中打开时，就不用修改项目属性了。\n在解决方案目录下新建一个名为\u0026quot;gdal\u0026quot;的文件夹 将vcpkg/installed/x64-windows下的bin、debug、include、lib文件夹拷贝至刚刚新建的gdal文件夹中 接下来我们正式开始进行项目属性设置（以Debug配置为例）\n设置附加包含目录 - 告知编译器头文件的所在目录\n在\u0026quot;C/C++\u0026quot;-\u0026ldquo;常规\u0026rdquo;-\u0026ldquo;附加包含目录\u0026quot;中填写$(SolutionDir)gdal\\include\n设置附加库目录 - 告知编译器.lib库文件的所在目录\n在\u0026quot;链接器\u0026rdquo;-\u0026ldquo;常规\u0026rdquo;-\u0026ldquo;附加库目录\u0026quot;中填写$(SolutionDir)gdal\\debug\\lib\n设置环境 - 告知编译器.dll库文件的所在目录\n在\u0026quot;调试\u0026rdquo;-\u0026ldquo;环境\u0026quot;中填写Path = $(SolutionDir)gdal\\debug\\bin\n设置附加依赖项 - 告知编译器要链接的库文件\n在\u0026quot;链接器\u0026rdquo;-\u0026ldquo;输入\u0026rdquo;-\u0026ldquo;附加依赖项\u0026quot;中填写gdald.lib\n最后点击确定，项目属性设置完毕。\n测试 在main.cpp文件中输入如下代码，注意要将第7行中的文件路径改成你自己的，第13行中的函数实参也要做相应的修改。\n#include \u0026lt;ogrsf_frmts.h\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int main() { GDALAllRegister();\t// 自动注册所有驱动，只能读不能写 GDALDataset* poDS = static_cast\u0026lt;GDALDataset*\u0026gt;(GDALOpenEx( \u0026#34;.","title":"gdal C++开发环境搭建"}]