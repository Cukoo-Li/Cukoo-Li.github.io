[{"content":"KMP算法是著名的字符串匹配算法。所谓字符串匹配，其实就是子串（常称为模式串）的定位操作，它求的是模式串在主串中的位置。\n对朴素模式匹配算法的改进 对于字符串匹配问题，我们很容易想到暴力解法（即朴素模式匹配算法）：枚举主串中的每一个位置，考虑以其作为起点，与模式串中对应位置的元素进行匹配。一旦在某个位置匹配不上（失配），就考虑以下一个位置为起点，重新与模式串进行匹配，如此反复进行。\n很显然，朴素模式匹配算法的时间复杂度为$O(n×m)$。\nint strStr(string haystack, string needle) { for (int i = 0; i + needle.size() \u0026lt;= haystack.size(); ++i) { bool flag = true; for (int j = 0; j \u0026lt; needle.size(); ++j) { if (haystack[i + j] != needle[j]) { flag = false; break; } } if (flag) return i; } return -1; } 朴素模式匹配算法的思想真的很朴素——不管在什么位置，只要发生失配，都选择以主串起点的下一个位置作为新起点，与模式串从头开始匹配。但这真的有必要吗？换句话说，发生失配时，我们真的需要以下一个位置为起点从头再来吗？是否有更好的选择呢？肯定是有的，下面我们来分析一下。\n以下图为例，当我们在模式串下标为5的位置发生失配时，主串中对应于子串前面的部分（即主串下标为3到7的部分）的内容，我们是知道的。因为这些位置跟与模式串是匹配的。\n按照暴力解法，接下来的一轮匹配操作将如下图所示。我们可以把这一轮匹配操作分为两个部分：首先是与主串中已知部分的匹配（橙色部分），然后是与主串中未知部分匹配（绿色部分）。对于橙色部分，实际上就相当于拿着模式串中0到4子串(\u0026quot;abaab\u0026quot;)的长度为4的前缀(\u0026quot;abaa\u0026quot;)和长度为4的后缀(\u0026quot;baab\u0026quot;)进行匹配。但这个结果我们是可以事先计算好的，因为它只与模式串相关，而且模式串本身较短，计算量并不大。如果我们事先已经知道\u0026quot;abaab\u0026quot;长度为4的前后缀不相等，我们就完全没必要考虑以主串位置4为起点。\n同理，以主串位置5为起点也是没有必要的，因为\u0026quot;abaab\u0026quot;长度为3的前后缀并不相等。\n但以主串位置6为起点是有必要的，因为\u0026quot;abaab\u0026quot;长度为2的前后缀是相等的，都是\u0026quot;ab\u0026quot;。此时，我们应该从子串下标为2的位置开始匹配，如下图所示：\n从上述例子中，我们可以归纳出如下解决方案，它适用于在模式串各个位置发生失配的情况：\n当在模式串下标为j的位置与主串位置i发生失配时，指针j可以直接跳转到某一下标重新与主串的当前位置i进行比较，这个下标等于模式串中0到j - 1子串的最长相等前后缀长度。如下图所示：\n因此，我们只需要事先计算出模式串中0到j - 1子串的最长相等前后缀长度，就能省去朴素模式匹配算法中许多不必要的比较操作。这就是KMP算法的核心思想。\nKMP算法核心思想 KMP算法的核心思想可总结为如下两点：\n计算next数组，next[j]表示模式串中0 - j子串的最长相等前后缀长度 在模式串下标为j的位置与主串发生失配时，跳转到next[j - 1]的位置重新与主串的当前位置进行比较 通过这一思路，可以实现主串指针不回溯，算法时间复杂度为$O(n+m)$。\nKMP算法代码实现 vector\u0026lt;int\u0026gt; BuildNext(const string\u0026amp; patt) { vector\u0026lt;int\u0026gt; next(patt.size(), 0); int prefix_len = 0;\t// 当前的共同前后缀长度 int i = 1; while (i \u0026lt; patt.size()) { if (patt[i] == patt[prefix_len]) next[i++] = ++prefix_len; else if (prefix_len == 0) next[i++] = 0; else prefix_len = next[prefix_len - 1]; } return next; } int KMP(string haystack, string needle) { auto next = BuildNext(needle); int i = 0; // 主串指针 int j = 0; // 子串指针 while (i \u0026lt; haystack.size()) { if (haystack[i] == needle[j]) {\t// 字符匹配，指针后移 ++i; ++j; } else if (j \u0026gt; 0)\t// 失配，根据next修改子串指针j j = next[j - 1]; else // 子串第一个字符就错了 ++i; if (j == needle.size())\t// 匹配成功 return i - j; } return -1; } 结语 实际上，KMP算法最难的地方就是next数组的计算。然而我并没有对这方面进行讲解，主要是因为最近太忙了，写博客是一件比较花时间的事情，等后面有空了再来把这部分内容补上吧。\n","permalink":"https://cukoohhh.cn/posts/kmp%E7%AE%97%E6%B3%95/","summary":"KMP算法是著名的字符串匹配算法。所谓字符串匹配，其实就是子串（常称为模式串）的定位操作，它求的是模式串在主串中的位置。\n对朴素模式匹配算法的改进 对于字符串匹配问题，我们很容易想到暴力解法（即朴素模式匹配算法）：枚举主串中的每一个位置，考虑以其作为起点，与模式串中对应位置的元素进行匹配。一旦在某个位置匹配不上（失配），就考虑以下一个位置为起点，重新与模式串进行匹配，如此反复进行。\n很显然，朴素模式匹配算法的时间复杂度为$O(n×m)$。\nint strStr(string haystack, string needle) { for (int i = 0; i + needle.size() \u0026lt;= haystack.size(); ++i) { bool flag = true; for (int j = 0; j \u0026lt; needle.size(); ++j) { if (haystack[i + j] != needle[j]) { flag = false; break; } } if (flag) return i; } return -1; } 朴素模式匹配算法的思想真的很朴素——不管在什么位置，只要发生失配，都选择以主串起点的下一个位置作为新起点，与模式串从头开始匹配。但这真的有必要吗？换句话说，发生失配时，我们真的需要以下一个位置为起点从头再来吗？是否有更好的选择呢？肯定是有的，下面我们来分析一下。\n以下图为例，当我们在模式串下标为5的位置发生失配时，主串中对应于子串前面的部分（即主串下标为3到7的部分）的内容，我们是知道的。因为这些位置跟与模式串是匹配的。\n按照暴力解法，接下来的一轮匹配操作将如下图所示。我们可以把这一轮匹配操作分为两个部分：首先是与主串中已知部分的匹配（橙色部分），然后是与主串中未知部分匹配（绿色部分）。对于橙色部分，实际上就相当于拿着模式串中0到4子串(\u0026quot;abaab\u0026quot;)的长度为4的前缀(\u0026quot;abaa\u0026quot;)和长度为4的后缀(\u0026quot;baab\u0026quot;)进行匹配。但这个结果我们是可以事先计算好的，因为它只与模式串相关，而且模式串本身较短，计算量并不大。如果我们事先已经知道\u0026quot;abaab\u0026quot;长度为4的前后缀不相等，我们就完全没必要考虑以主串位置4为起点。\n同理，以主串位置5为起点也是没有必要的，因为\u0026quot;abaab\u0026quot;长度为3的前后缀并不相等。\n但以主串位置6为起点是有必要的，因为\u0026quot;abaab\u0026quot;长度为2的前后缀是相等的，都是\u0026quot;ab\u0026quot;。此时，我们应该从子串下标为2的位置开始匹配，如下图所示：\n从上述例子中，我们可以归纳出如下解决方案，它适用于在模式串各个位置发生失配的情况：\n当在模式串下标为j的位置与主串位置i发生失配时，指针j可以直接跳转到某一下标重新与主串的当前位置i进行比较，这个下标等于模式串中0到j - 1子串的最长相等前后缀长度。如下图所示：\n因此，我们只需要事先计算出模式串中0到j - 1子串的最长相等前后缀长度，就能省去朴素模式匹配算法中许多不必要的比较操作。这就是KMP算法的核心思想。\nKMP算法核心思想 KMP算法的核心思想可总结为如下两点：","title":"KMP算法"},{"content":"tinyhttpd是一个非常简易的HTTP服务器程序，适合Linux服务器编程入门学习。从中不仅可以学习到HTTP服务器对一个HTTP请求的响应过程，还能熟悉一些最基本的Linux网络编程api的使用方法。\n以下是我对tinyhttpd程序逻辑的简单总结，可以对照公开的源码进行阅读（推荐详细注释版），在阅读之前读者应该了解计算机网络以及Linux服务器编程的基本知识。\n程序主要工作流程 服务器启动，在某个端口绑定httpd服务，等待HTTP请求（main建立监听socket） 收到一个HTTP请求时（监听socket被accept后得到一个连接socket），对它进行处理（执行accept_request函数） 解析HTTP请求报文的请求行，从中提取出method和url，根据两者的内容执行相应的业务逻辑 对于GET方法，解析url，获取客户所请求的文件路径path。如果path是一个目录，则追加\u0026quot;index.html\u0026quot;，表示访问主页。如果path不存在，则报错返回。否则，如果path存在且不是可执行文件，就将该文件封装成响应报文发送给客户（文件基本信息作为首部行，文件内容作为实体主体），跳到最后一步 对于POST方法以及“GET一个可执行文件”，后续将执行cgi业务逻辑 执行cgi业务逻辑 建立两个单向管道用于进程间通信 创建子进程 在子进程中，首先将标准输入输出分别重定向到输入管道的读端和输出管道的写端，然后设置环境变量，执行cgi脚本文件 在父进程中，首先，如果有必要，通过管道将请求行后面的内容发送给子进程。然后，将子进程通过管道发来的数据发送给客户 关闭连接socket，完成对一次HTTP请求的响应。 重要函数解读 main 设定服务端口号 创建监听socket（详细工作交由startup函数完成） 循环阻塞等待客户连接 一旦收到客户连接（accept成功返回一个连接socket），就处理它（详细工作交由accept_request函数完成） 程序退出前关闭监听socket startup 该函数的主要工作是创建一个监听socket，并将其返回给main\n创建一个使用TCP协议的socket（通过调用socket函数，指定协议族和服务类型） 设定socket地址结构（涉及通过地址转换函数完成主机字节序到网络字节序的转换） 给socket命名，也就是给刚刚创建好的socket绑定一个socket地址（通过调用bind函数，端口号已由main给出） 如果main给出的端口号为0，即bind中指定的socket地址端口号为0，系统会随机选择一个临时端口号。在这种情况下，我们需要知道系统给监听socket实际分配的端口号是多少（通过getsockname获取，注意要进行字节序转换） 调用listen函数，让命名后的socket变为监听socket（系统会创建一个监听队列以存放待处理的客户连接） 返回监听socket accept_request 该函数的主要工作是处理一个HTTP请求。由于该服务器程序实现的是非持续连接的HTTP，即每个HTTP请求都对应一次连接，因此该函数实际上是在处理一个连接socket。\n解析HTTP请求报文的请求行，获取method以及url（通过调用自定义函数get_line，从连接socket中读取一行，进而处理字符序列）\n根据method和url中的信息，明确这个HTTP请求需要执行cgi程序还是仅索要文件\nPOST\n需要执行cgi程序，将cgi标志变量(cgi)置1。\nGET\n解析url，获取请求的路径(path)。（url中'?'后面的字符串表示请求的路径）\npath是一个目录（以'/'结尾），就拼接上\u0026quot;index.html\u0026quot;，使其变成文件 path是一个文件或目录，就查询path所表示的文件或目录是否存在（利用stat函数）： 不存在，就把该HTTP请求的后续内容读完并忽略，然后返回一个表示“找不到文件”的相应报文给客户（详细工作交由not_found函数完成） 存在，就考察它究竟是一个目录还是一个文件（利用st_mode） 是目录，就拼接上\u0026quot;index.html\u0026quot;，使其变成文件 是可执行文件，需要调用cgi程序，将cgi置1 根据cgi的值，发送文件(serve_file)或执行cig程序(execute_cgi)\n关闭连接socket\nexecute_cgi 该函数的主要工作是进行cgi业务逻辑，该过程涉及创建子进程、利用管道进行进程间通信、执行cgi脚本文件。\n如果请求方法是GET，就读取并忽略请求行后面的所有内容（实际上请求行后面的内容只有首部行，因为没有实体主体） 如果请求方法是POST，在首部行中寻找表示实体主体长度的字段，并记录实体主体长度（如果没有给出长度，则报错返回） 给客户发送响应报文中状态行内容(send + \u0026quot;HTTP/1.0 200 OK\\r\\n\u0026quot;) 创建两个单向管道(cgi_output和cgi_input)，用于进程间通信(pipe) 创建子进程(fork) 子进程将执行cgi脚本 关闭cgi_output[0]和cgi_input[1]，因为子进程不使用这两端 将标准输入重定向到输出管道的写端，这样一来，子进程输出的内容就会直接写到输出管道的写端 将标准输入重定向到输入管道的读端，这样一来，子进程输入的内容就来自输入管道的读端 设置环境变量 执行cgi脚本文件(execl) 父进程作为连接socket和子进程之间I/O的中介 关闭cgi_output[1]和cgi_input[0]，因为父进程不使用这两端 如果请求方法是POST，则继续读取实体主体中的内容，并写到cgi_input[1]，让子进程去读 从cgi_output[0]中读取子进程的输出，并将其发送给客户 关闭管道，并等待子进程退出 （完）\n","permalink":"https://cukoohhh.cn/posts/tinyhttpd%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91%E6%80%BB%E7%BB%93/","summary":"tinyhttpd是一个非常简易的HTTP服务器程序，适合Linux服务器编程入门学习。从中不仅可以学习到HTTP服务器对一个HTTP请求的响应过程，还能熟悉一些最基本的Linux网络编程api的使用方法。\n以下是我对tinyhttpd程序逻辑的简单总结，可以对照公开的源码进行阅读（推荐详细注释版），在阅读之前读者应该了解计算机网络以及Linux服务器编程的基本知识。\n程序主要工作流程 服务器启动，在某个端口绑定httpd服务，等待HTTP请求（main建立监听socket） 收到一个HTTP请求时（监听socket被accept后得到一个连接socket），对它进行处理（执行accept_request函数） 解析HTTP请求报文的请求行，从中提取出method和url，根据两者的内容执行相应的业务逻辑 对于GET方法，解析url，获取客户所请求的文件路径path。如果path是一个目录，则追加\u0026quot;index.html\u0026quot;，表示访问主页。如果path不存在，则报错返回。否则，如果path存在且不是可执行文件，就将该文件封装成响应报文发送给客户（文件基本信息作为首部行，文件内容作为实体主体），跳到最后一步 对于POST方法以及“GET一个可执行文件”，后续将执行cgi业务逻辑 执行cgi业务逻辑 建立两个单向管道用于进程间通信 创建子进程 在子进程中，首先将标准输入输出分别重定向到输入管道的读端和输出管道的写端，然后设置环境变量，执行cgi脚本文件 在父进程中，首先，如果有必要，通过管道将请求行后面的内容发送给子进程。然后，将子进程通过管道发来的数据发送给客户 关闭连接socket，完成对一次HTTP请求的响应。 重要函数解读 main 设定服务端口号 创建监听socket（详细工作交由startup函数完成） 循环阻塞等待客户连接 一旦收到客户连接（accept成功返回一个连接socket），就处理它（详细工作交由accept_request函数完成） 程序退出前关闭监听socket startup 该函数的主要工作是创建一个监听socket，并将其返回给main\n创建一个使用TCP协议的socket（通过调用socket函数，指定协议族和服务类型） 设定socket地址结构（涉及通过地址转换函数完成主机字节序到网络字节序的转换） 给socket命名，也就是给刚刚创建好的socket绑定一个socket地址（通过调用bind函数，端口号已由main给出） 如果main给出的端口号为0，即bind中指定的socket地址端口号为0，系统会随机选择一个临时端口号。在这种情况下，我们需要知道系统给监听socket实际分配的端口号是多少（通过getsockname获取，注意要进行字节序转换） 调用listen函数，让命名后的socket变为监听socket（系统会创建一个监听队列以存放待处理的客户连接） 返回监听socket accept_request 该函数的主要工作是处理一个HTTP请求。由于该服务器程序实现的是非持续连接的HTTP，即每个HTTP请求都对应一次连接，因此该函数实际上是在处理一个连接socket。\n解析HTTP请求报文的请求行，获取method以及url（通过调用自定义函数get_line，从连接socket中读取一行，进而处理字符序列）\n根据method和url中的信息，明确这个HTTP请求需要执行cgi程序还是仅索要文件\nPOST\n需要执行cgi程序，将cgi标志变量(cgi)置1。\nGET\n解析url，获取请求的路径(path)。（url中'?'后面的字符串表示请求的路径）\npath是一个目录（以'/'结尾），就拼接上\u0026quot;index.html\u0026quot;，使其变成文件 path是一个文件或目录，就查询path所表示的文件或目录是否存在（利用stat函数）： 不存在，就把该HTTP请求的后续内容读完并忽略，然后返回一个表示“找不到文件”的相应报文给客户（详细工作交由not_found函数完成） 存在，就考察它究竟是一个目录还是一个文件（利用st_mode） 是目录，就拼接上\u0026quot;index.html\u0026quot;，使其变成文件 是可执行文件，需要调用cgi程序，将cgi置1 根据cgi的值，发送文件(serve_file)或执行cig程序(execute_cgi)\n关闭连接socket\nexecute_cgi 该函数的主要工作是进行cgi业务逻辑，该过程涉及创建子进程、利用管道进行进程间通信、执行cgi脚本文件。\n如果请求方法是GET，就读取并忽略请求行后面的所有内容（实际上请求行后面的内容只有首部行，因为没有实体主体） 如果请求方法是POST，在首部行中寻找表示实体主体长度的字段，并记录实体主体长度（如果没有给出长度，则报错返回） 给客户发送响应报文中状态行内容(send + \u0026quot;HTTP/1.0 200 OK\\r\\n\u0026quot;) 创建两个单向管道(cgi_output和cgi_input)，用于进程间通信(pipe) 创建子进程(fork) 子进程将执行cgi脚本 关闭cgi_output[0]和cgi_input[1]，因为子进程不使用这两端 将标准输入重定向到输出管道的写端，这样一来，子进程输出的内容就会直接写到输出管道的写端 将标准输入重定向到输入管道的读端，这样一来，子进程输入的内容就来自输入管道的读端 设置环境变量 执行cgi脚本文件(execl) 父进程作为连接socket和子进程之间I/O的中介 关闭cgi_output[1]和cgi_input[0]，因为父进程不使用这两端 如果请求方法是POST，则继续读取实体主体中的内容，并写到cgi_input[1]，让子进程去读 从cgi_output[0]中读取子进程的输出，并将其发送给客户 关闭管道，并等待子进程退出 （完）","title":"tinyhttpd程序逻辑总结"},{"content":"手写shared_ptr是面试的常考点，提前准备一下吧。\nshared_ptr的关键特性 首先明确shared_ptr的关键特性：\n允许多个shared_ptr指向同一个对象 每个shared_ptr都有一个关联的引用计数，用于记录总共有多少个shared_ptr指向相同的对象 一旦一个shared_ptr所关联的引用计数变为0，它就会自动释放自己所管理的对象 代码思路 显然，最关键的就是要实现引用计数这个机制，大致思路如下：\n在堆中创建一个整型对象作为引用计数 在拷贝或赋值时修改引用计数 在析构函数中递减引用计数，并考察它是否变为0，如果变为0，则释放所指向的对象以及引用计数对象 代码实现 #include \u0026lt;iostream\u0026gt; template \u0026lt;typename T\u0026gt; class TinySharedPtr { public: // 构造函数 explicit TinySharedPtr(T* ptr = nullptr) : ptr_(ptr) { if (ptr_) count_ = new int(1); } // 拷贝构造函数 TinySharedPtr(const TinySharedPtr\u0026amp; other) : ptr_(other.ptr_), count_(other.count_) { if (count_) ++*count_; } // 拷贝赋值运算符 TinySharedPtr\u0026amp; operator=(TinySharedPtr other) { std::swap(ptr_, other.ptr_); std::swap(count_, other.count_); return *this; } // 析构函数 ~TinySharedPtr() { if (count_ \u0026amp;\u0026amp; --(*count_) == 0) { delete ptr_; delete count_; } } T* get() { return ptr_; } T* operator-\u0026gt;() { return ptr_; } T\u0026amp; operator*() { return *ptr_; } int use_count() { return count_ ? *count_ : 0; } private: T* ptr_ = nullptr; int* count_ = nullptr; }; struct Cukoo { Cukoo() { puts(\u0026#34;Cukoo()\u0026#34;); } ~Cukoo() { puts(\u0026#34;~Cukoo()\u0026#34;); } int age = 24; }; int main() { TinySharedPtr\u0026lt;Cukoo\u0026gt; sp0; std::cout \u0026lt;\u0026lt; \u0026#34;sp0: \u0026#34; \u0026lt;\u0026lt; sp0.use_count() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; { TinySharedPtr\u0026lt;Cukoo\u0026gt; sp1(new Cukoo()); std::cout \u0026lt;\u0026lt; \u0026#34;age: \u0026#34; \u0026lt;\u0026lt; sp1-\u0026gt;age \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;sp1: \u0026#34; \u0026lt;\u0026lt; sp1.use_count() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; TinySharedPtr\u0026lt;Cukoo\u0026gt; sp2(sp1); std::cout \u0026lt;\u0026lt; \u0026#34;sp2: \u0026#34; \u0026lt;\u0026lt; sp2.use_count() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; sp0 = sp2; std::cout \u0026lt;\u0026lt; \u0026#34;sp0: \u0026#34; \u0026lt;\u0026lt; sp2.use_count() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } std::cout \u0026lt;\u0026lt; \u0026#34;sp0: \u0026#34; \u0026lt;\u0026lt; sp0.use_count() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } // sp0: 0 // Cukoo() // age: 24 // sp1: 1 // sp2: 2 // sp0: 3 // sp0: 1 // ~Cukoo() ","permalink":"https://cukoohhh.cn/posts/%E6%89%8B%E5%86%99shared-ptr/","summary":"手写shared_ptr是面试的常考点，提前准备一下吧。\nshared_ptr的关键特性 首先明确shared_ptr的关键特性：\n允许多个shared_ptr指向同一个对象 每个shared_ptr都有一个关联的引用计数，用于记录总共有多少个shared_ptr指向相同的对象 一旦一个shared_ptr所关联的引用计数变为0，它就会自动释放自己所管理的对象 代码思路 显然，最关键的就是要实现引用计数这个机制，大致思路如下：\n在堆中创建一个整型对象作为引用计数 在拷贝或赋值时修改引用计数 在析构函数中递减引用计数，并考察它是否变为0，如果变为0，则释放所指向的对象以及引用计数对象 代码实现 #include \u0026lt;iostream\u0026gt; template \u0026lt;typename T\u0026gt; class TinySharedPtr { public: // 构造函数 explicit TinySharedPtr(T* ptr = nullptr) : ptr_(ptr) { if (ptr_) count_ = new int(1); } // 拷贝构造函数 TinySharedPtr(const TinySharedPtr\u0026amp; other) : ptr_(other.ptr_), count_(other.count_) { if (count_) ++*count_; } // 拷贝赋值运算符 TinySharedPtr\u0026amp; operator=(TinySharedPtr other) { std::swap(ptr_, other.ptr_); std::swap(count_, other.count_); return *this; } // 析构函数 ~TinySharedPtr() { if (count_ \u0026amp;\u0026amp; --(*count_) == 0) { delete ptr_; delete count_; } } T* get() { return ptr_; } T* operator-\u0026gt;() { return ptr_; } T\u0026amp; operator*() { return *ptr_; } int use_count() { return count_ ?","title":"手写shared_ptr"},{"content":"内部排序算法是面试中的常考点，其中快速排序和归并排序是重点。\n以下是我对常见的内部排序算法的简单总结，仅供自己复习之用，不涉及详细的算法讲解。\n插入排序 插入排序是一种简单直观的排序方法，其基本思想是每次将一个待排序的元素按其关键字大小插入到前面已排好序的子表中，直到全部元素插入完成。\n由插入排序的思想可以引申出三个重要的排序算法：直接插入排序、折半插入排序、希尔排序。\n直接插入排序 算法思想\n初始时将第一个元素视为已排好序的子表，然后依次将后面的元素插入到已排好序的子表中。\n算法实现\nvoid StraightInsertionSort(vector\u0026lt;int\u0026gt;\u0026amp; nums) { // 将各元素插入到前面排好序的子表中 for (int i = 1; i \u0026lt; nums.size(); ++i) { int temp = nums[i]; int j; // 前面排好序的子表中比待插入元素大的都要向后挪一个位置 for (j = i - 1; j \u0026gt;= 0 \u0026amp;\u0026amp; nums[j] \u0026gt; temp; --j) nums[j + 1] = nums[j]; // 将待插入元素复制到插入位置 nums[j + 1] = temp; } } 算法分析\n空间复杂度$O(1)$ 时间复杂度$O(n^2)$ 稳定性：稳定 折半插入排序 算法思想\n当排序表是顺序表时，可以对直接插入排序算法做如下改进：使用折半查找来确定待插入位置，然后再统一地向后移动元素。\n算法实现\nvoid BinaryInsertionSort(vector\u0026lt;int\u0026gt;\u0026amp; nums) { for (int i = 1; i \u0026lt; nums.size(); ++i) { int temp = nums[i]; // 二分查找插入位置 int left = 0; int right = i - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (temp \u0026lt; nums[mid]) right = mid - 1; else left = mid + 1; } // 从插入位置开始往后的元素都要向后挪一个位置 for (int j = i - 1; j \u0026gt;= left; --j) nums[j + 1] = nums[j]; // 将待插入元素复制到插入位置 nums[left] = temp; } } 算法分析\n空间复杂度$O(1)$ 时间复杂度$O(n^2)$：仅减少了比较元素的次数，而移动元素的次数并未改变 稳定性：稳定 希尔排序 算法思想\n直接插入排序算法的时间复杂度为O(n^2)，但若待排表为“正序”时，其时间复杂度可提高至O(n)，由此可见它更适用于基本有序的排序表和数据量不大的排序表。希尔排序正是基于这两点分析对直接插入排序进行改进而得来的，又称缩小增量排序。\n希尔排序的基本思想是：先将待排序表分割成若干形如{i, i+d, i+2d, ..., i+kd}的“子表”，即把相隔某个“增量”的元素组成一个子表，对各个子表分别进行直接插入排序。逐步减少增量d，使排序表逐步呈现“基本有序”的情形，最终d=1，即对全体元素进行一次直接插入排序。\n算法实现\nvoid ShellSort(vector\u0026lt;int\u0026gt;\u0026amp; nums) { for (int d = nums.size() / 2; d \u0026gt;= 1; d /= 2) { // 步长变化 // 从子表的第二个元素开始，进行直接插入排序 for (int i = d; i \u0026lt; nums.size(); ++i) { int temp = nums[i]; int j; for (j = i - d; j \u0026gt;= 0 \u0026amp;\u0026amp; nums[j] \u0026gt; temp; j -= d) nums[j + d] = nums[j]; nums[j + d] = temp; } } } 算法分析\n空间复杂度$O(1)$ 时间复杂度：比直接插入排序要低，具体多少未知，这是数学上尚未解决的难题 稳定性：不稳定，当相同的元素被划分到不同的子表时，可能会改变它们之间的相对次序 交换排序 冒泡排序 算法思想\n从后往前（或从前往后）两两比较相邻元素值，若为逆序，则交换它们。我们称这是一趟冒泡，每趟冒泡的结果会将最小的元素交换到待排序表的第一个位置。下一趟冒泡时，前一趟确定的最小元素（或最大元素）不再参与比较。这样最多做n-1趟就能完成排序。\n算法实现\nvoid BubbleSort(vector\u0026lt;int\u0026gt;\u0026amp; nums) { for (int i = 0; i \u0026lt; nums.size() - 1; ++i) { bool swaped = false; // 记录本趟冒泡是否发生过交换 for (int j = nums.size() - 1; j \u0026gt; i; --j) { if (nums[j - 1] \u0026gt; nums[j]) { swap(nums[j - 1], nums[j]); swaped = true; } } if (swaped == false) // 没有发生过交换，说明已经有序 return; } } 算法分析\n空间复杂度$O(1)$ 时间复杂度$O(n^2)$ 稳定性：稳定，相邻元素相等时，不会发生交换 快速排序 算法思想\n在待排序表{1...n}中任取一个元素作为枢轴pivot，通过一趟排序将待排序表划分为独立的两部分{1...k-1}和{k+1...n}，使得{1...k-1}中的所有元素小于枢轴pivot，{k+1...n}中所有元素大于等于枢轴pivot，则枢轴pivot放在了其最终位置k上，这个过程称为一趟快速排序（或一次划分）。然后分别递归地对两个子表重复上述过程，直至子表内只有一个元素或为空为止，即所有元素都放在了其最终位置上。\n算法实现\nvoid QuickSort(vector\u0026lt;int\u0026gt;\u0026amp; nums, int left, int right) { if (left \u0026lt; right) { // 递归跳出的条件 int pivot_index = Partition(nums, left, right); // 划分 // 分别对两个子表进行递归排序 QuickSort(nums, left, pivot_index - 1); QuickSort(nums, pivot_index + 1, right); } } int Partition(vector\u0026lt;int\u0026gt;\u0026amp; nums, int left, int right) { int pivot = nums[left]; // 将第一个元素作为枢轴 while (left \u0026lt; right) { // 循环跳出条件 // 将小于枢轴的元素移动到左边 while (left \u0026lt; right \u0026amp;\u0026amp; nums[right] \u0026gt;= pivot) --right; nums[left] = nums[right]; // 将大于等于枢轴的元素移动到右边 while (left \u0026lt; right \u0026amp;\u0026amp; nums[left] \u0026lt; pivot) ++left; nums[right] = nums[left]; } nums[left] = pivot; // 将枢轴元素放到最终位置 return left; } 算法分析\n空间复杂度$O(log_2n)$：快速排序的递归调用过程可以看成是一棵结点数为n的二叉树，空间复杂度取决于树的深度，平均空间复杂度与最好空间复杂度接近 时间复杂度$O(nlog_2n)$：在树的每一层中的时间复杂度不超过$O(n)$，时间复杂度为$O(n×树的深度)$ 稳定性：不稳定 选择排序 选择排序的基本思想是每次从待排序表中选出最小（或最大）的元素，加入到有序子表中。\n简单选择排序 算法思想\n通过遍历的方式，从待排序表中最小（或最大）的元素，放入有序子表的末尾（即与待排序表的首元素交换），直至待排序表为空。\n算法实现\nvoid SimpleSelectionSort(vector\u0026lt;int\u0026gt;\u0026amp; nums) { for (int i = 0; i \u0026lt; nums.size() - 1; ++i) { int minIndex = i; // 记录最小元素下标 for (int j = i + 1; j \u0026lt; nums.size(); ++j) { if (nums[j] \u0026lt; nums[minIndex]) minIndex = j; } if (minIndex != i) swap(nums[i], nums[minIndex]); } } 算法分析\n空间复杂度$O(1)$ 时间复杂度$O(n^2)$ 稳定性：不稳定，例如{2,2',1}排序后会变为{1,2',2} 堆排序 算法思想\n在堆这种数据结构中，最小（或最大）的元素位于堆顶。因此，只要始终将待排序表维护成堆，然后每次都将堆顶元素加入到有序子表中，就能实现排序。\n算法实现\n以大根堆为例\n初始建堆\n将待排序表视为以数组形式存储的完全二叉树，从后往前依次对所有分支结点进行调整，因为只有分支结点才有可能不满足大根堆的性质，且从后往前依次进行调整可以复用前面的处理结果，有点像动态规划的味道。\n调整的具体做法是：如果不满足大根堆性质，则将当前结点与较大的孩子交换。这样做的结果是把一个较小的结点交换到下面，这可能会破坏下一级的堆，因此要采用相同的方法继续调整。（“小元素不断下坠”）\n将堆顶元素加入到有序子表\n这一步是通过将堆顶元素与堆底元素互换实现的。\n新堆顶元素不断下坠\n堆顶元素发生改变，大根堆的性质可能遭到破坏。因此需要进行调整，也就是让堆顶元素不断下坠。\nvoid HeapSort(vector\u0026lt;int\u0026gt;\u0026amp; nums) { // 将待排序表转换为以数组形式存储的完全二叉树（根结点下标为1） nums.resize(nums.size() + 1); for (int i = nums.size() - 1; i \u0026gt; 0; --i) nums[i] = nums[i - 1]; // 堆排序 BuildMaxHeap(nums); // 初始建堆 for (int i = nums.size() - 1; i \u0026gt; 1; i--) { // n-1趟交换和调整 swap(nums[i], nums[1]); HeadAdjust(nums, 1, i); } // 复原待排序表 for (int i = 0; i \u0026lt; nums.size() - 1; ++i) nums[i] = nums[i + 1]; nums.resize(nums.size() - 1); } void BuildMaxHeap(vector\u0026lt;int\u0026gt;\u0026amp; nums) { for (int i = nums.size() / 2; i \u0026gt; 0; --i) HeadAdjust(nums, i, nums.size()); } // 以k为根结点的树仅在根结点位置不满足大根堆性质 // 对根结点k的位置进行调整 // 该过程可形象地描述为“小元素不断下坠” void HeadAdjust(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k, int end) { nums[0] = nums[k]; // nums[0]用于暂存根结点的值 // 寻找适合放置根结点的位置k for (int i = 2 * k; i \u0026lt; end; i *= 2) { if (i + 1 \u0026lt; end \u0026amp;\u0026amp; nums[i] \u0026lt; nums[i + 1]) ++i; if (nums[0] \u0026gt;= nums[i]) // 如果将根结点放到位置k，是否符合大根堆的性质 break; else { nums[k] = nums[i]; k = i; } } nums[k] = nums[0]; // 将根结点放到位置k } 算法分析\n空间复杂度$O(1)$ 时间复杂度$O(nlog_2n)$：建堆的时间复杂度为$O(n)$（具体计算较复杂），每次调整的时间复杂度与下坠层数有关，但不超过$O(log_2n)$，共有n-1次调整 稳定性：不稳定 归并排序和基数排序 归并排序 算法思想\n将待排序表视为n个只含1个元素的有序子表，然后两两归并，合并成一个更大的有序表，直到合并成一个长度为n的有序表为止。\n算法实现\nvector\u0026lt;int\u0026gt; temp; void MergeSort(vector\u0026lt;int\u0026gt;\u0026amp; nums, int left, int right) { temp.resize(nums.size(), 0); if (left \u0026lt; right) { int mid = left + (right - left) / 2; // 从中间划分 MergeSort(nums, left, mid); // 对左半部分进行归并排序 MergeSort(nums, mid + 1, right); // 对右半部分进行归并排序 Merge(nums, left, mid, right); // 归并 } } // [left, mid]和[mid + 1, right]各自有序，将二者归并 void Merge(vector\u0026lt;int\u0026gt;\u0026amp; nums, int left, int mid, int right) { // 将区间内nums的元素拷贝到temp中 copy(nums.begin() + left, nums.begin() + right + 1, temp.begin() + left); // 三指针，依次取较小值 int i, j, k; for (i = left, j = mid + 1, k = left; i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= right; ++k) { if (temp[i] \u0026lt;= temp[j]) nums[k] = temp[i++]; else nums[k] = temp[j++]; } // 将较长有序表中剩余的元素依次取完 while (i \u0026lt;= mid) nums[k++] = temp[i++]; while (j \u0026lt;= right) nums[k++] = temp[j++]; } 算法分析\n空间复杂度$O(n)$：辅助数组所需空间为$O(n)$。归并排序的递归调用过程可以看成是一棵最后一层结点数为n的二叉树，递归调用栈所需空间$O(log_2n)$ 时间复杂度$O(nlog_2n)$：归并的趟数与树高有关，为$O(log_2n)$，每趟归并的时间复杂度为$O(n)$ 稳定性：稳定，归并操作可以不改变相同元素的相对次序 基数排序 算法思想\n假设元素的关键字可拆分为d个位（或称“组”），每个关键字位可能取得有限的r个值，按照关键字位权重递增的次序，做d趟“分配”和“收集”，这个过程中需要建立r个队列。\n分配：顺序扫描各个元素，若当前处理的关键字位为x，则将其插入到队列Q~x~中 收集：令各个队列中的元素依次出队并链接 算法实现\n略\n算法分析\n空间复杂度$O(r)$：需要r个辅助队列 时间复杂度$O(d(n+r))$：需要进行d趟分配和收集，一趟分配需要$O(n)$，一趟收集需要$O(r)$ 总结 在上述排序算法中，\n时间复杂度为$O(nlog_2n)$的算法一般都不稳定，其中只有归并排序是稳定的 时间复杂度为$O(n^2)$的算法一般都稳定，其中只有简单选择排序是不稳定的 希尔排序、折半插入排序不适用于链表，堆排序不建议使用链表实现，其余排序算法均适用于链表。 （完）\n","permalink":"https://cukoohhh.cn/posts/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/","summary":"内部排序算法是面试中的常考点，其中快速排序和归并排序是重点。\n以下是我对常见的内部排序算法的简单总结，仅供自己复习之用，不涉及详细的算法讲解。\n插入排序 插入排序是一种简单直观的排序方法，其基本思想是每次将一个待排序的元素按其关键字大小插入到前面已排好序的子表中，直到全部元素插入完成。\n由插入排序的思想可以引申出三个重要的排序算法：直接插入排序、折半插入排序、希尔排序。\n直接插入排序 算法思想\n初始时将第一个元素视为已排好序的子表，然后依次将后面的元素插入到已排好序的子表中。\n算法实现\nvoid StraightInsertionSort(vector\u0026lt;int\u0026gt;\u0026amp; nums) { // 将各元素插入到前面排好序的子表中 for (int i = 1; i \u0026lt; nums.size(); ++i) { int temp = nums[i]; int j; // 前面排好序的子表中比待插入元素大的都要向后挪一个位置 for (j = i - 1; j \u0026gt;= 0 \u0026amp;\u0026amp; nums[j] \u0026gt; temp; --j) nums[j + 1] = nums[j]; // 将待插入元素复制到插入位置 nums[j + 1] = temp; } } 算法分析\n空间复杂度$O(1)$ 时间复杂度$O(n^2)$ 稳定性：稳定 折半插入排序 算法思想\n当排序表是顺序表时，可以对直接插入排序算法做如下改进：使用折半查找来确定待插入位置，然后再统一地向后移动元素。\n算法实现\nvoid BinaryInsertionSort(vector\u0026lt;int\u0026gt;\u0026amp; nums) { for (int i = 1; i \u0026lt; nums.","title":"常见的内部排序算法总结"},{"content":"前言 在开发中，我们经常会使用到第三方库，以避免造轮子，从而提高开发效率。在C++中使用第三方库，首先需要进行以下步骤：\n获取库文件和头文件 告知编译器头文件的所在目录 告知编译器库文件的所在目录 告知编译器要链接的库文件 库文件的获取主要有两种方式：\n库厂商有提供库文件，自行选择所需版本下载即可 库厂商没有提供库文件，但开放了源代码，此时就需要自己根据源代码进行编译，得到所需的库文件 所有的库文件都提供有相应的头文件作为调用它的接口。换言之，我们在拿到库文件的同时，也拿到了头文件。\n搭建使用第三方库的C++开发环境的核心步骤是固定的，也就是上述提到的4个步骤，但具体操作因平台和开发工具而异。\n前段时间一直忙于软著的开发，其中涉及到了gdal库的调用。以下将分享我个人在搭建gdal C++开发环境时所做的记录，希望能够帮到有需要的人。\n基于vcpkg的gdal库编译 vcpkg是微软推出的开源的C/C++库管理器，它能够自动为我们处理库编译所需的各种依赖关系，就像是Python中的miniconda。\n下载vcpkg\n使用git-bash中执行以下命令，以下载vcpkg。\ngit clone https://github.com/microsoft/vcpkg.git 如果你没有git，打开上述命令中的网址，点击\u0026quot;Code\u0026quot;-\u0026ldquo;Download ZIP\u0026rdquo;，下载后解压即可。\n使用vcpkg进行gdal库编译\n在vcpkg文件夹的上级目录中，使用命令提示符(cmd)依次执行以下命令。\n.\\vcpkg\\bootstrap-vcpkg.bat .\\vcpkg\\vcpkg install gdal:x64-windows 接下来，可以喝杯茶、摸会儿鱼，等待编译完成。编译耗时因电脑性能而异，在我的电脑中，耗时42分钟。\n查看库文件和头文件\n进入vcpkg/installed/x64-windows\nbin和lib文件夹中分别存放着适用于Relese模式下的动态库文件(.dll)和静态库（也可能是动态库的导入库）文件(.lib) debug中的bin和lib文件夹分别存放着适用于Debug模式下的动态库文件(.dll)和静态库（也可能是动态库的导入库）文件(.lib) include文件夹中存放着头文件 以上就是基于vcpkg进行gdal库编译的操作过程，本文没有对相关命令进行讲解，更多详细信息请参考vcpkg的GitHub仓库中的README.md。\nVisual Studio项目属性设置 打开Visual Studio，创建一个C++空项目，在项目中添加一个.cpp文件。随后，在项目右键菜单中点击“属性”，将弹出如下图所示的“[项目名]属性页”。\n在设置项目属性之前，我们可以先将库文件和头文件放到项目文件夹中，这样在后续的项目设置中，就可以尽量使用相对路径。这样做的好处是，当我们将整个项目打包，放到其他电脑中打开时，就不用修改项目属性了。\n在解决方案目录下新建一个名为\u0026quot;gdal\u0026quot;的文件夹 将vcpkg/installed/x64-windows下的bin、debug、include、lib文件夹拷贝至刚刚新建的gdal文件夹中 接下来我们正式开始进行项目属性设置（以Debug配置为例）\n设置附加包含目录 - 告知编译器头文件的所在目录\n在\u0026quot;C/C++\u0026quot;-\u0026ldquo;常规\u0026rdquo;-\u0026ldquo;附加包含目录\u0026quot;中填写$(SolutionDir)gdal\\include\n设置附加库目录 - 告知编译器.lib库文件的所在目录\n在\u0026quot;链接器\u0026rdquo;-\u0026ldquo;常规\u0026rdquo;-\u0026ldquo;附加库目录\u0026quot;中填写$(SolutionDir)gdal\\debug\\lib\n设置环境 - 告知编译器.dll库文件的所在目录\n在\u0026quot;调试\u0026rdquo;-\u0026ldquo;环境\u0026quot;中填写Path = $(SolutionDir)gdal\\debug\\bin\n设置附加依赖项 - 告知编译器要链接的库文件\n在\u0026quot;链接器\u0026rdquo;-\u0026ldquo;输入\u0026rdquo;-\u0026ldquo;附加依赖项\u0026quot;中填写gdald.lib\n最后点击确定，项目属性设置完毕。\n测试 在main.cpp文件中输入如下代码，注意要将第7行中的文件路径改成你自己的，第13行中的函数实参也要做相应的修改。\n#include \u0026lt;ogrsf_frmts.h\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int main() { GDALAllRegister();\t// 自动注册所有驱动，只能读不能写 GDALDataset* poDS = static_cast\u0026lt;GDALDataset*\u0026gt;(GDALOpenEx( \u0026#34;./data/point.shp\u0026#34;, GDAL_OF_VECTOR, nullptr, nullptr, nullptr));\t// 创建Dataset if (poDS == nullptr) { cout \u0026lt;\u0026lt; \u0026#34;open failed.\u0026#34; \u0026lt;\u0026lt; endl; exit(1); } OGRLayer* poLayer = poDS-\u0026gt;GetLayerByName(\u0026#34;point\u0026#34;);\t// 获取Layer，shapefile格式的LayerName就是文件名 OGRFeatureDefn* poFDefn = poLayer-\u0026gt;GetLayerDefn();\t// 获取Layer的定义（包含Geometry和Field的定义） poLayer-\u0026gt;ResetReading();\t// 重置游标 OGRFeature* poFeature; while ((poFeature = poLayer-\u0026gt;GetNextFeature()) != nullptr) {\t// 输出Layer中所有Feature的字段值 for (int iField = 0; iField \u0026lt; poFDefn-\u0026gt;GetFieldCount(); ++iField) { OGRFieldDefn* poFieldDefn = poFDefn-\u0026gt;GetFieldDefn(iField); switch (poFieldDefn-\u0026gt;GetType()) { case OFTInteger: printf(\u0026#34;%d,\u0026#34;, poFeature-\u0026gt;GetFieldAsInteger(iField)); break; case OFTInteger64: printf(CPL_FRMT_GIB \u0026#34;,\u0026#34;, poFeature-\u0026gt;GetFieldAsInteger64(iField)); break; case OFTReal: printf(\u0026#34;%.3f,\u0026#34;, poFeature-\u0026gt;GetFieldAsDouble(iField)); break; case OFTString: printf(\u0026#34;%s,\u0026#34;, poFeature-\u0026gt;GetFieldAsString(iField)); break; default: printf(\u0026#34;%s,\u0026#34;, poFeature-\u0026gt;GetFieldAsString(iField)); break; } } cout \u0026lt;\u0026lt; endl; OGRFeature::DestroyFeature(poFeature);\t// GetNextFeature()返回的是一个对象的拷贝，需要自行销毁 } return 0; } 点击“开始调试”，不出意外的话，程序可以正常运行。\n但是，控制台首行会提示\u0026quot;Cannot find proj.db\u0026rdquo;。所谓的\u0026quot;proj.db\u0026quot;实际存放在vcpkg\\installed\\x64-windows\\share\\proj中，我们可以使用以下两种方式让程序找到它。\n利用名为\u0026quot;PROJ_LIB\u0026quot;的环境变量，指明\u0026quot;proj.db\u0026quot;所在目录\n将\u0026quot;proj.db\u0026quot;拷贝到项目目录以及可执行文件所在目录\n（完）\n","permalink":"https://cukoohhh.cn/posts/gdal-c++%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","summary":"前言 在开发中，我们经常会使用到第三方库，以避免造轮子，从而提高开发效率。在C++中使用第三方库，首先需要进行以下步骤：\n获取库文件和头文件 告知编译器头文件的所在目录 告知编译器库文件的所在目录 告知编译器要链接的库文件 库文件的获取主要有两种方式：\n库厂商有提供库文件，自行选择所需版本下载即可 库厂商没有提供库文件，但开放了源代码，此时就需要自己根据源代码进行编译，得到所需的库文件 所有的库文件都提供有相应的头文件作为调用它的接口。换言之，我们在拿到库文件的同时，也拿到了头文件。\n搭建使用第三方库的C++开发环境的核心步骤是固定的，也就是上述提到的4个步骤，但具体操作因平台和开发工具而异。\n前段时间一直忙于软著的开发，其中涉及到了gdal库的调用。以下将分享我个人在搭建gdal C++开发环境时所做的记录，希望能够帮到有需要的人。\n基于vcpkg的gdal库编译 vcpkg是微软推出的开源的C/C++库管理器，它能够自动为我们处理库编译所需的各种依赖关系，就像是Python中的miniconda。\n下载vcpkg\n使用git-bash中执行以下命令，以下载vcpkg。\ngit clone https://github.com/microsoft/vcpkg.git 如果你没有git，打开上述命令中的网址，点击\u0026quot;Code\u0026quot;-\u0026ldquo;Download ZIP\u0026rdquo;，下载后解压即可。\n使用vcpkg进行gdal库编译\n在vcpkg文件夹的上级目录中，使用命令提示符(cmd)依次执行以下命令。\n.\\vcpkg\\bootstrap-vcpkg.bat .\\vcpkg\\vcpkg install gdal:x64-windows 接下来，可以喝杯茶、摸会儿鱼，等待编译完成。编译耗时因电脑性能而异，在我的电脑中，耗时42分钟。\n查看库文件和头文件\n进入vcpkg/installed/x64-windows\nbin和lib文件夹中分别存放着适用于Relese模式下的动态库文件(.dll)和静态库（也可能是动态库的导入库）文件(.lib) debug中的bin和lib文件夹分别存放着适用于Debug模式下的动态库文件(.dll)和静态库（也可能是动态库的导入库）文件(.lib) include文件夹中存放着头文件 以上就是基于vcpkg进行gdal库编译的操作过程，本文没有对相关命令进行讲解，更多详细信息请参考vcpkg的GitHub仓库中的README.md。\nVisual Studio项目属性设置 打开Visual Studio，创建一个C++空项目，在项目中添加一个.cpp文件。随后，在项目右键菜单中点击“属性”，将弹出如下图所示的“[项目名]属性页”。\n在设置项目属性之前，我们可以先将库文件和头文件放到项目文件夹中，这样在后续的项目设置中，就可以尽量使用相对路径。这样做的好处是，当我们将整个项目打包，放到其他电脑中打开时，就不用修改项目属性了。\n在解决方案目录下新建一个名为\u0026quot;gdal\u0026quot;的文件夹 将vcpkg/installed/x64-windows下的bin、debug、include、lib文件夹拷贝至刚刚新建的gdal文件夹中 接下来我们正式开始进行项目属性设置（以Debug配置为例）\n设置附加包含目录 - 告知编译器头文件的所在目录\n在\u0026quot;C/C++\u0026quot;-\u0026ldquo;常规\u0026rdquo;-\u0026ldquo;附加包含目录\u0026quot;中填写$(SolutionDir)gdal\\include\n设置附加库目录 - 告知编译器.lib库文件的所在目录\n在\u0026quot;链接器\u0026rdquo;-\u0026ldquo;常规\u0026rdquo;-\u0026ldquo;附加库目录\u0026quot;中填写$(SolutionDir)gdal\\debug\\lib\n设置环境 - 告知编译器.dll库文件的所在目录\n在\u0026quot;调试\u0026rdquo;-\u0026ldquo;环境\u0026quot;中填写Path = $(SolutionDir)gdal\\debug\\bin\n设置附加依赖项 - 告知编译器要链接的库文件\n在\u0026quot;链接器\u0026rdquo;-\u0026ldquo;输入\u0026rdquo;-\u0026ldquo;附加依赖项\u0026quot;中填写gdald.lib\n最后点击确定，项目属性设置完毕。\n测试 在main.cpp文件中输入如下代码，注意要将第7行中的文件路径改成你自己的，第13行中的函数实参也要做相应的修改。\n#include \u0026lt;ogrsf_frmts.h\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int main() { GDALAllRegister();\t// 自动注册所有驱动，只能读不能写 GDALDataset* poDS = static_cast\u0026lt;GDALDataset*\u0026gt;(GDALOpenEx( \u0026#34;.","title":"gdal C++开发环境搭建"}]